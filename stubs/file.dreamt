// Generated by: dream bindgen
// Do not edit manually.

// Erlang module: file
extern mod file {
    fn native_name_encoding() -> any;
    fn format_error(reason: any) -> string;
    fn pid2name(pid_: pid) -> Option<(atom, any)>;
    fn get_cwd() -> Result<any, any>;
    fn get_cwd(drive: string) -> Result<any, any>;
    fn set_cwd(dir: any) -> Result<(), any>;
    fn delete(filename: binary) -> Result<(), any>;
    fn delete(filename: binary, opts: [atom]) -> Result<(), any>;
    fn rename(source: binary, destination: binary) -> Result<(), any>;
    fn make_dir(dir: binary) -> Result<(), any>;
    fn del_dir(dir: binary) -> Result<(), any>;
    fn del_dir_r(file: binary) -> Result<(), any>;
    fn read_file_info(file: any) -> Result<any, any>;
    fn read_file_info(file: any, opts: [any]) -> Result<any, any>;
    fn altname(name: any) -> any;
    fn read_link_info(name: binary) -> Result<any, any>;
    fn read_link_info(name: binary, opts: [any]) -> Result<any, any>;
    fn read_link(name: binary) -> Result<any, any>;
    fn read_link_all(name: binary) -> Result<any, any>;
    fn write_file_info(filename: binary, fileinfo: any) -> Result<(), any>;
    fn write_file_info(filename: binary, fileinfo: any, opts: [any]) -> Result<(), any>;
    fn list_dir(dir: binary) -> Result<any, any>;
    fn list_dir_all(dir: binary) -> Result<any, any>;
    fn read_file(filename: binary) -> Result<any, any>;
    fn make_link(existing: binary, new: binary) -> Result<(), any>;
    fn make_symlink(existing: binary, new: binary) -> Result<(), any>;
    fn write_file(filename: binary, bytes: any) -> Result<(), any>;
    fn write_file(filename: binary, bytes: any, modes: [any]) -> Result<(), any>;
    fn open(file: any, modes: [any]) -> Result<any, any>;
    fn close(iodevice: any) -> Result<(), any>;
    fn advise(iodevice: any, offset: int, length: int, advise: atom) -> Result<(), any>;
    fn allocate(file: any, offset: int, length: int) -> Result<(), any>;
    fn read(iodevice: any, number: int) -> any;
    fn read_line(iodevice: any) -> any;
    fn pread(iodevice: any, locnums: any) -> any;
    fn pread(iodevice: any, location: any, number: int) -> any;
    fn write(iodevice: any, bytes: any) -> Result<(), any>;
    fn pwrite(iodevice: any, locbytes: any) -> Result<(), (any, any)>;
    fn pwrite(iodevice: any, location: any, bytes: any) -> Result<(), any>;
    fn datasync(iodevice: any) -> Result<(), any>;
    fn sync(iodevice: any) -> Result<(), any>;
    fn position(iodevice: any, location: any) -> Result<any, any>;
    fn truncate(iodevice: any) -> Result<(), any>;
    fn copy(source: any, destination: any) -> Result<any, any>;
    fn copy(source: any, destination: any, bytecount: any) -> Result<any, any>;
    fn consult(filename: binary) -> Result<any, any>;
    fn path_consult(path: [binary], filename: binary) -> any;
    fn eval(filename: binary) -> Result<(), any>;
    fn eval(filename: binary, bindings: any) -> Result<(), any>;
    fn path_eval(path: any, filename: binary) -> Result<any, any>;
    fn path_eval(path: any, filename: binary, bindings: any) -> Result<any, any>;
    fn script(filename: binary) -> Result<any, any>;
    fn script(filename: binary, bindings: any) -> Result<any, any>;
    fn path_script(path: any, filename: binary) -> any;
    fn path_script(path: any, filename: binary, bindings: any) -> any;
    fn path_open(path: any, filename: binary, modes: [any]) -> any;
    fn change_mode(filename: binary, mode: int) -> Result<(), any>;
    fn change_owner(filename: binary, uid: int) -> Result<(), any>;
    fn change_owner(filename: binary, uid: int, gid: int) -> Result<(), any>;
    fn change_group(filename: binary, gid: int) -> Result<(), any>;
    fn change_time(filename: binary, mtime: ((int, int, int), (int, int, int))) -> Result<(), any>;
    fn change_time(filename: binary, atime: ((int, int, int), (int, int, int)), mtime: ((int, int, int), (int, int, int))) -> Result<(), any>;
    fn sendfile(rawfile: any, socket: any, offset: int, bytes: int, opts: [any]) -> Result<int, any>;
    fn sendfile(filename: binary, socket: any) -> Result<int, any>;
}

