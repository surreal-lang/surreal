// Generated by: dream bindgen
// Do not edit manually.

// Erlang module: lists
extern mod lists {
    fn keyfind(key: any, n: int, tuplelist: [any]) -> any;
    fn keymember(key: any, n: int, tuplelist: [any]) -> bool;
    fn keysearch(key: any, n: int, tuplelist: [any]) -> any;
    fn member(elem: any, list_: [any]) -> bool;
    fn reverse(list1: [any], tail: any) -> [any];
    fn append(list1: [any], list2: [any]) -> [any];
    fn append(listoflists: [[any]]) -> [any];
    fn subtract(list1: [any], list2: [any]) -> [any];
    fn reverse(list1: [any]) -> [any];
    fn nth(n: int, list_: [any]) -> any;
    fn nthtail(n: int, list_: [any]) -> [any];
    fn prefix(list1: [any], list2: [any]) -> bool;
    fn suffix(list1: [any], list2: [any]) -> bool;
    fn droplast(list_: [any]) -> [any];
    fn last(list_: [any]) -> any;
    fn seq(from: int, to: int) -> [int];
    fn seq(from: int, to: int, incr: int) -> [int];
    fn sum(list_: [int]) -> int;
    fn duplicate(n: int, elem: any) -> [any];
    fn min(list_: [any]) -> any;
    fn max(list_: [any]) -> any;
    fn sublist(list1: [any], start: int, len: int) -> [any];
    fn sublist(list1: [any], len: int) -> [any];
    fn delete(elem: any, list1: [any]) -> [any];
    fn zip(list1: [any], list2: [any]) -> [(any, any)];
    fn zip(list1: [any], list2: [any], how: any) -> [(any, any)];
    fn unzip(list1: [(any, any)]) -> ([any], [any]);
    fn zip3(list1: [any], list2: [any], list3: [any]) -> [(any, any, any)];
    fn zip3(list1: [any], list2: [any], list3: [any], how: any) -> [(any, any, any)];
    fn unzip3(list1: [(any, any, any)]) -> ([any], [any], [any]);
    fn zipwith(combine: fn(any, any) -> any, list1: [any], list2: [any]) -> [any];
    fn zipwith(combine: fn(any, any) -> any, list1: [any], list2: [any], how: any) -> [any];
    fn zipwith3(combine: fn(any, any, any) -> any, list1: [any], list2: [any], list3: [any]) -> [any];
    fn zipwith3(combine: fn(any, any, any) -> any, list1: [any], list2: [any], list3: [any], how: any) -> [any];
    fn sort(list1: [any]) -> [any];
    fn merge(listoflists: [[any]]) -> [any];
    fn merge3(list1: [any], list2: [any], list3: [any]) -> [any];
    fn rmerge3(arg0: [any], arg1: [any], arg2: [any]) -> [any];
    fn merge(list1: [any], list2: [any]) -> [any];
    fn rmerge(arg0: [any], arg1: [any]) -> [any];
    fn concat(things: [any]) -> string;
    fn flatten(deeplist: [any]) -> [any];
    fn flatten(deeplist: [any], tail: [any]) -> [any];
    fn flatlength(deeplist: [any]) -> int;
    fn keydelete(key: any, n: int, tuplelist1: [any]) -> [any];
    fn keyreplace(key: any, n: int, tuplelist1: [any], newtuple: any) -> [any];
    fn keytake(key: any, n: int, tuplelist1: [any]) -> any;
    fn keystore(key: any, n: int, tuplelist1: [any], newtuple: any) -> [any];
    fn keysort(n: int, tuplelist1: [any]) -> [any];
    fn keymerge(n: int, tuplelist1: [any], tuplelist2: [any]) -> [any];
    fn rkeymerge(arg0: int, arg1: [any], arg2: [any]) -> [any];
    fn ukeysort(n: int, tuplelist1: [any]) -> [any];
    fn ukeymerge(n: int, tuplelist1: [any], tuplelist2: [any]) -> [any];
    fn rukeymerge(arg0: int, arg1: [any], arg2: [any]) -> [any];
    fn keymap(fun: any, n: int, tuplelist1: [any]) -> [any];
    fn enumerate(list1: [any]) -> [(int, any)];
    fn enumerate(index: int, list1: [any]) -> [(int, any)];
    fn enumerate(index: int, step: int, list1: [any]) -> [(int, any)];
    fn sort(fun: any, list1: [any]) -> [any];
    fn merge(fun: fn(any, any) -> bool, list1: [any], list2: [any]) -> [any];
    fn rmerge(arg0: fn(any, any) -> bool, arg1: [any], arg2: [any]) -> [any];
    fn usort(fun: fn(any, any) -> bool, list1: [any]) -> [any];
    fn umerge(fun: fn(any, any) -> bool, list1: [any], list2: [any]) -> [any];
    fn rumerge(arg0: fn(any, any) -> bool, arg1: [any], arg2: [any]) -> [any];
    fn usort(list1: [any]) -> [any];
    fn umerge(listoflists: [[any]]) -> [any];
    fn umerge3(list1: [any], list2: [any], list3: [any]) -> [any];
    fn rumerge3(arg0: [any], arg1: [any], arg2: [any]) -> [any];
    fn umerge(list1: [any], list2: [any]) -> [any];
    fn rumerge(arg0: [any], arg1: [any]) -> [any];
    fn all(pred: any, list_: [any]) -> bool;
    fn any(pred: any, list_: [any]) -> bool;
    fn map(fun: fn(any) -> any, list1: [any]) -> [any];
    fn flatmap(fun: fn(any) -> [any], list1: [any]) -> [any];
    fn foldl(fun: any, acc0: any, list_: [any]) -> any;
    fn foldr(fun: any, acc0: any, list_: [any]) -> any;
    fn filter(pred: any, list1: [any]) -> [any];
    fn partition(pred: any, list_: [any]) -> ([any], [any]);
    fn filtermap(fun: any, list1: [any]) -> [any];
    fn zf(arg0: any, arg1: [any]) -> [any];
    fn foreach(fun: any, list_: [any]) -> atom;
    fn mapfoldl(fun: fn(any, any) -> (any, any), acc0: any, list1: [any]) -> ([any], any);
    fn mapfoldr(fun: fn(any, any) -> (any, any), acc0: any, list1: [any]) -> ([any], any);
    fn takewhile(pred: any, list1: [any]) -> [any];
    fn dropwhile(pred: any, list1: [any]) -> [any];
    fn search(pred: fn(any) -> bool, list_: [any]) -> any;
    fn splitwith(pred: fn(any) -> bool, list_: [any]) -> ([any], [any]);
    fn split(n: int, list1: [any]) -> ([any], [any]);
    fn join(sep: any, list1: [any]) -> [any];
    fn uniq(list1: [any]) -> [any];
    fn uniq(fun: fn(any) -> any, list1: [any]) -> [any];
}

