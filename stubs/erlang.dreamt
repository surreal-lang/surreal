// Generated by: dream bindgen
// Do not edit manually.

// Erlang module: erlang
extern mod erlang {
    fn adler32(data: any) -> int;
    fn adler32(oldadler: int, data: any) -> int;
    fn adler32_combine(firstadler: int, secondadler: int, secondsize: int) -> int;
    fn append_element(tuple1: any, term: any) -> any;
    fn atom_to_binary(atom_: atom) -> any;
    fn atom_to_binary(atom_: atom, encoding: any) -> any;
    fn atom_to_list(atom_: atom) -> [any];
    fn binary_part(subject: any, poslen: any) -> any;
    fn binary_part(subject: any, start: int, length: int) -> any;
    fn binary_to_atom(binary_: any) -> atom;
    fn binary_to_atom(binary_: any, encoding: any) -> atom;
    fn binary_to_existing_atom(binary_: any) -> atom;
    fn binary_to_existing_atom(binary_: any, encoding: any) -> atom;
    fn binary_to_float(binary_: any) -> float;
    fn binary_to_integer(binary_: any) -> int;
    fn binary_to_integer(binary_: any, base: any) -> int;
    fn binary_to_list(binary_: any) -> [any];
    fn binary_to_list(binary_: any, start: int, stop: int) -> [any];
    fn binary_to_term(binary_: any) -> any;
    fn binary_to_term(binary_: any, opts: [any]) -> any;
    fn bit_size(bitstring: any) -> int;
    fn bitstring_to_list(bitstring: any) -> [any];
    fn bump_reductions(reductions: int) -> atom;
    fn byte_size(bitstring: any) -> int;
    fn call_on_load_function(p1: atom) -> any;
    fn cancel_timer(timerref: ref) -> any;
    fn cancel_timer(timerref: ref, options: [any]) -> any;
    fn ceil(number: any) -> int;
    fn check_old_code(module: atom) -> bool;
    fn check_process_code(pid_: pid, module: atom) -> bool;
    fn check_process_code(pid_: pid, module: atom, optionlist: [any]) -> any;
    fn crc32(data: any) -> int;
    fn crc32(oldcrc: int, data: any) -> int;
    fn crc32_combine(firstcrc: int, secondcrc: int, secondsize: int) -> int;
    fn date() -> (int, int, int);
    fn decode_packet(type_: atom, bin: any, options: [any]) -> any;
    fn delete_element(index: int, tuple1: any) -> any;
    fn delete_module(module: atom) -> Option<atom>;
    fn demonitor(monitorref: ref) -> atom;
    fn demonitor(monitorref: ref, optionlist: [any]) -> bool;
    fn alias() -> ref;
    fn alias(opts: [atom]) -> ref;
    fn unalias(alias: ref) -> bool;
    fn display(term: any) -> atom;
    fn display_string(p1: any) -> atom;
    fn display_string(device: any, p1: [any]) -> atom;
    fn dt_append_vm_tag_data(iodata: any) -> any;
    fn dt_get_tag() -> Option<binary>;
    fn dt_get_tag_data() -> Option<binary>;
    fn dt_prepend_vm_tag_data(iodata: any) -> any;
    fn dt_put_tag(iodata: any) -> Option<binary>;
    fn dt_restore_tag(tagdata: any) -> atom;
    fn dt_spread_tag(arg0: any) -> any;
    fn erase() -> [(any, any)];
    fn erase(key: any) -> Option<any>;
    fn error(reason: any) -> any;
    fn error(reason: any, args: any) -> any;
    fn error(reason: any, args: any, options: [(atom, any)]) -> any;
    fn exit(reason: any) -> any;
    fn exit(pid_: any, reason: any) -> atom;
    fn exit_signal(pid_: any, reason: any) -> atom;
    fn external_size(term: any) -> int;
    fn external_size(term: any, options: any) -> int;
    fn finish_loading(preparedcodelist: [ref]) -> any;
    fn finish_after_on_load(p1: atom, p2: bool) -> atom;
    fn float(number: any) -> float;
    fn float_to_binary(float_: float) -> any;
    fn float_to_binary(float_: float, options: [any]) -> any;
    fn float_to_list(float_: float) -> [any];
    fn float_to_list(float_: float, options: [any]) -> [any];
    fn floor(number: any) -> int;
    fn fun_info(fun: fn() -> any, item: any) -> (any, any);
    fn fun_info_mfa(fun: fn() -> any) -> (atom, atom, int);
    fn fun_to_list(fun: fn() -> any) -> [any];
    fn function_exported(module: atom, function: atom, arity: int) -> bool;
    fn garbage_collect() -> atom;
    fn garbage_collect(pid_: pid) -> bool;
    fn garbage_collect(pid_: pid, optionlist: [any]) -> any;
    fn garbage_collect_message_area() -> bool;
    fn get() -> [(any, any)];
    fn get(key: any) -> Option<any>;
    fn get_keys() -> [any];
    fn get_keys(val: any) -> [any];
    fn get_module_info(module: atom) -> [(any, any)];
    fn group_leader() -> pid;
    fn group_leader(groupleader: pid, pid_: pid) -> atom;
    fn halt() -> any;
    fn halt(status: any) -> any;
    fn halt(status: int, options: any) -> any;
    fn has_prepared_code_on_load(preparedcode: ref) -> bool;
    fn hibernate(module: atom, function: atom, args: [any]) -> any;
    fn insert_element(index: int, tuple1: any, term: any) -> any;
    fn integer_to_binary(integer_: int) -> any;
    fn integer_to_list(integer_: int) -> [any];
    fn iolist_size(item: any) -> int;
    fn iolist_to_binary(iolistorbinary: any) -> any;
    fn iolist_to_iovec(iolistorbinary: any) -> [any];
    fn is_alive() -> bool;
    fn is_builtin(module: atom, function: atom, arity: int) -> bool;
    fn is_map_key(key: any, map_: any) -> bool;
    fn is_process_alive(pid_: pid) -> bool;
    fn length(list_: [any]) -> int;
    fn link(pidorport: any) -> atom;
    fn list_to_atom(string_: [any]) -> atom;
    fn list_to_binary(iolist: [any]) -> any;
    fn list_to_bitstring(bitstringlist: [any]) -> any;
    fn list_to_existing_atom(string_: [any]) -> atom;
    fn list_to_float(string_: [any]) -> float;
    fn list_to_integer(string_: [any]) -> int;
    fn list_to_integer(string_: [any], base: any) -> int;
    fn list_to_pid(string_: [any]) -> pid;
    fn list_to_port(string_: [any]) -> any;
    fn list_to_ref(string_: [any]) -> ref;
    fn list_to_tuple(list_: [any]) -> any;
    fn loaded() -> [atom];
    fn localtime() -> ((int, int, int), (int, int, int));
    fn make_ref() -> ref;
    fn map_size(map_: any) -> int;
    fn map_get(key: any, map_: any) -> any;
    fn match_spec_test(matchagainst: any, matchspec: any, type_: any) -> any;
    fn md5(data: any) -> any;
    fn md5_final(context: any) -> any;
    fn md5_init() -> any;
    fn md5_update(context: any, data: any) -> any;
    fn module_loaded(module: atom) -> bool;
    fn monitor(arg0: any, arg1: any) -> ref;
    fn monitor(arg0: any, arg1: any, arg2: [any]) -> ref;
    fn monitor_node(node: atom, flag: bool) -> atom;
    fn monitor_node(node: atom, flag: bool, options: [any]) -> atom;
    fn nif_error(reason: any) -> any;
    fn nif_error(reason: any, args: [any]) -> any;
    fn node() -> atom;
    fn node(arg: any) -> atom;
    fn now() -> any;
    fn phash(term: any, range: int) -> int;
    fn phash2(term: any) -> int;
    fn phash2(term: any, range: int) -> int;
    fn pid_to_list(pid_: pid) -> [any];
    fn port_to_list(port: any) -> [any];
    fn ports() -> [any];
    fn posixtime_to_universaltime(p1: int) -> ((int, int, int), (int, int, int));
    fn unique_integer(modifierlist: [any]) -> int;
    fn unique_integer() -> int;
    fn monotonic_time() -> int;
    fn monotonic_time(unit: any) -> int;
    fn system_time() -> int;
    fn system_time(unit: any) -> int;
    fn convert_time_unit(time: int, fromunit: any, tounit: any) -> int;
    fn time_offset() -> int;
    fn time_offset(unit: any) -> int;
    fn timestamp() -> any;
    fn prepare_loading(module: atom, code: any) -> any;
    fn pre_loaded() -> [atom];
    fn process_display(pid_: pid, type_: any) -> atom;
    fn process_flag(pid_: pid, flag: any, value: int) -> int;
    fn process_info(pid_: pid) -> Option<[any]>;
    fn processes() -> [pid];
    fn purge_module(module: atom) -> atom;
    fn put(key: any, val: any) -> any;
    fn raise(class: atom, reason: any, stacktrace: any) -> atom;
    fn read_timer(timerref: ref) -> any;
    fn read_timer(timerref: ref, options: [(any, bool)]) -> any;
    fn ref_to_list(ref_: ref) -> [any];
    fn register(regname: atom, pidorport: any) -> atom;
    fn registered() -> [atom];
    fn resume_process(suspendee: pid) -> atom;
    fn round(number: any) -> int;
    fn self() -> pid;
    fn send_after(time: int, dest: any, msg: any) -> ref;
    fn send_after(time: int, dest: any, msg: any, options: [(any, bool)]) -> ref;
    fn seq_trace(p1: atom, p2: any) -> any;
    fn seq_trace_print(p1: any) -> bool;
    fn seq_trace_print(p1: any, p2: any) -> bool;
    fn setnode(p1: atom, p2: int) -> atom;
    fn setnode(node: atom, distctrlr: any, opts: (int, int)) -> atom;
    fn size(item: any) -> int;
    fn spawn(module: atom, function: atom, args: [any]) -> pid;
    fn spawn_link(module: atom, function: atom, args: [any]) -> pid;
    fn split_binary(bin: any, pos: int) -> (any, any);
    fn start_timer(time: int, dest: any, msg: any) -> ref;
    fn start_timer(time: int, dest: any, msg: any, options: [(any, bool)]) -> ref;
    fn suspend_process(suspendee: pid, optlist: [any]) -> bool;
    fn suspend_process(suspendee: pid) -> atom;
    fn system_monitor() -> Option<(any, any)>;
    fn system_monitor(arg: Option<(any, any)>) -> Option<(any, any)>;
    fn system_monitor(monitorpid: pid, options: [any]) -> Option<(any, any)>;
    fn system_profile() -> Option<(any, any)>;
    fn system_profile(profilerpid: any, options: [atom]) -> Option<(any, [any])>;
    fn throw(any: any) -> any;
    fn time() -> (int, int, int);
    fn trace(pidportspec: any, how: bool, flaglist: [any]) -> int;
    fn trace_delivered(tracee: any) -> ref;
    fn trace_info(pidportfuncevent: any, item: any) -> any;
    fn trunc(number: any) -> int;
    fn tuple_size(tuple_: any) -> int;
    fn universaltime() -> ((int, int, int), (int, int, int));
    fn universaltime_to_posixtime(p1: ((int, int, int), (int, int, int))) -> int;
    fn unlink(id: any) -> atom;
    fn unregister(regname: atom) -> atom;
    fn whereis(regname: atom) -> any;
    fn abs(float_: int) -> float;
    fn append(list_: [any], tail: any) -> [any];
    fn element(n: int, tuple_: any) -> any;
    fn get_module_info(module: atom, item: any) -> any;
    fn hd(list_: [any]) -> any;
    fn is_atom(term: any) -> bool;
    fn is_binary(term: any) -> bool;
    fn is_bitstring(term: any) -> bool;
    fn is_boolean(term: any) -> bool;
    fn is_float(term: any) -> bool;
    fn is_function(term: any) -> bool;
    fn is_function(term: any, arity: int) -> bool;
    fn is_integer(term: any) -> bool;
    fn is_list(term: any) -> bool;
    fn is_number(term: any) -> bool;
    fn is_pid(term: any) -> bool;
    fn is_map(term: any) -> bool;
    fn is_port(term: any) -> bool;
    fn is_record(term: any, recordtag: atom) -> bool;
    fn is_record(term: any, recordtag: atom, size: int) -> bool;
    fn is_reference(term: any) -> bool;
    fn is_tuple(term: any) -> bool;
    fn load_module(module: atom, binary_: any) -> Result<any, any>;
    fn load_nif(path: [any], loadinfo: any) -> any;
    fn localtime_to_universaltime(localtime: ((int, int, int), (int, int, int)), isdst: any) -> ((int, int, int), (int, int, int));
    fn make_fun(module: atom, function: atom, arity: int) -> fn() -> any;
    fn make_tuple(arity: int, initialvalue: any) -> any;
    fn make_tuple(arity: int, defaultvalue: any, initlist: any) -> any;
    fn open_port(portname: any, portsettings: [any]) -> any;
    fn process_flag(arg0: any, boolean: bool) -> bool;
    fn process_info(pid_: pid, item: any) -> any;
    fn send(dest: any, msg: any) -> any;
    fn send(dest: any, msg: any, options: [any]) -> any;
    fn seq_trace_info(arg0: any) -> any;
    fn setelement(index: int, tuple1: any, value: any) -> any;
    fn statistics(arg0: any) -> [int];
    fn subtract(arg0: [any], arg1: [any]) -> [any];
    fn system_flag(arg0: any, depth: int) -> Option<any>;
    fn term_to_binary(term: any) -> any;
    fn term_to_binary(term: any, options: any) -> any;
    fn term_to_iovec(term: any) -> [any];
    fn term_to_iovec(term: any, options: any) -> [any];
    fn tl(list_: [any]) -> any;
    fn trace_pattern(mfa: any, matchspec: any) -> int;
    fn trace_pattern(arg0: any, matchspec: any, arg2: [any]) -> int;
    fn tuple_to_list(tuple_: any) -> [any];
    fn system_info(arg0: any) -> (Option<any>, [int], [atom], any);
    fn universaltime_to_localtime(universaltime: ((int, int, int), (int, int, int))) -> ((int, int, int), (int, int, int));
    fn apply(fun: fn() -> any, args: [any]) -> any;
    fn apply(module: atom, function: atom, args: [any]) -> any;
    fn spawn(fun: fn() -> any) -> pid;
    fn spawn(node: atom, fun: fn() -> any) -> pid;
    fn spawn_link(fun: fn() -> any) -> pid;
    fn spawn_link(node: atom, fun: fn() -> any) -> pid;
    fn spawn_monitor(fun: fn() -> any) -> (pid, ref);
    fn spawn_monitor(node: atom, fun: fn() -> any) -> (pid, ref);
    fn spawn_monitor(module: atom, function: atom, args: [any]) -> (pid, ref);
    fn spawn_opt(fun: fn() -> any, options: [any]) -> any;
    fn spawn_opt(node: atom, fun: fn() -> any, options: [any]) -> any;
    fn spawn(node: atom, module: atom, function: atom, args: [any]) -> pid;
    fn spawn_link(node: atom, module: atom, function: atom, args: [any]) -> pid;
    fn spawn_monitor(node: atom, module: atom, function: atom, args: [any]) -> (pid, ref);
    fn spawn_opt(module: atom, function: atom, args: [any], options: [any]) -> any;
    fn spawn_opt(node: atom, module: atom, function: atom, args: [any], options: [any]) -> any;
    fn spawn_request(fun: fn() -> any) -> ref;
    fn spawn_request(fun: fn() -> any, options: [any]) -> ref;
    fn spawn_request(node: atom, fun: fn() -> any, options: [any]) -> ref;
    fn spawn_request(node: atom, module: atom, function: atom, args: [any]) -> ref;
    fn spawn_request(node: atom, module: atom, function: atom, args: [any], options: [any]) -> ref;
    fn spawn_request_abandon(reqid: any) -> bool;
    fn yield() -> atom;
    fn nodes() -> [atom];
    fn nodes(arg: any) -> [atom];
    fn nodes(arg: any, infoopts: any) -> [(atom, any)];
    fn disconnect_node(node: atom) -> any;
    fn fun_info(fun: fn() -> any) -> [(any, any)];
    fn send_nosuspend(dest: any, msg: any) -> bool;
    fn send_nosuspend(dest: any, msg: any, options: [any]) -> bool;
    fn localtime_to_universaltime(localtime: ((int, int, int), (int, int, int))) -> ((int, int, int), (int, int, int));
    fn port_command(port: any, data: any) -> atom;
    fn port_command(port: any, data: any, optionlist: [any]) -> bool;
    fn port_connect(port: any, pid_: pid) -> atom;
    fn port_close(port: any) -> atom;
    fn port_control(port: any, operation: int, data: any) -> any;
    fn port_call(port: any, data: any) -> any;
    fn port_call(port: any, operation: int, data: any) -> any;
    fn port_info(port: any) -> Option<[any]>;
    fn port_info(port: any, arg1: any) -> Option<(any, any)>;
    fn port_set_data(port: any, data: any) -> atom;
    fn port_get_data(port: any) -> any;
    fn dist_ctrl_input_handler(dhandle: atom, inputhandler: pid) -> atom;
    fn dist_ctrl_put_data(dhandle: atom, data: any) -> atom;
    fn dist_ctrl_get_data(dhandle: atom) -> any;
    fn dist_ctrl_get_data_notification(dhandle: atom) -> atom;
    fn dist_ctrl_set_opt(dhandle: atom, arg1: atom, value: bool) -> bool;
    fn dist_ctrl_get_opt(dhandle: atom, arg1: atom) -> bool;
    fn dist_get_stat(dhandle: atom) -> (atom, int, int, int);
    fn delay_trap(result: any, arg1: any) -> any;
    fn set_cookie(cookie: atom) -> atom;
    fn set_cookie(node: atom, cookie: atom) -> atom;
    fn get_cookie() -> any;
    fn get_cookie(node: atom) -> any;
    fn integer_to_list(integer_: int, base: any) -> [any];
    fn integer_to_binary(integer_: int, base: any) -> any;
    fn min(term1: any, term2: any) -> any;
    fn max(term1: any, term2: any) -> any;
    fn memory() -> [(atom, int)];
    fn memory(type_: [atom]) -> [(atom, int)];
    fn gather_gc_info_result(ref_: ref) -> (any, any, any);
}

