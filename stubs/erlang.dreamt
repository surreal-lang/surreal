// Generated by: dream bindgen
// Do not edit manually.

// Erlang module: erlang
extern mod erlang {
    fn adler32(arg0: any) -> int;
    fn adler32(arg0: any, arg1: any) -> int;
    fn adler32_combine(arg0: any, arg1: any, arg2: any) -> int;
    fn append_element(arg0: any, arg1: any) -> any;
    fn atom_to_binary(arg0: any) -> binary;
    fn atom_to_binary(arg0: any, arg1: any) -> binary;
    fn atom_to_list(arg0: any) -> string;
    fn binary_part(arg0: any, arg1: any) -> binary;
    fn binary_part(arg0: any, arg1: any, arg2: any) -> binary;
    fn binary_to_atom(arg0: any) -> atom;
    fn binary_to_atom(arg0: any, arg1: any) -> atom;
    fn binary_to_existing_atom(arg0: any) -> atom;
    fn binary_to_existing_atom(arg0: any, arg1: any) -> atom;
    fn binary_to_float(arg0: any) -> float;
    fn binary_to_integer(arg0: any) -> int;
    fn binary_to_integer(arg0: any, arg1: any) -> int;
    fn binary_to_list(arg0: any) -> [int];
    fn binary_to_list(arg0: any, arg1: any, arg2: any) -> [int];
    fn binary_to_term(arg0: any) -> any;
    fn binary_to_term(arg0: any, arg1: any) -> any;
    fn bit_size(arg0: any) -> int;
    fn bitstring_to_list(arg0: any) -> [any];
    fn bump_reductions(arg0: any) -> atom;
    fn byte_size(arg0: any) -> int;
    fn call_on_load_function(arg0: any) -> any;
    fn cancel_timer(arg0: any) -> any;
    fn cancel_timer(arg0: any, arg1: any) -> any;
    fn ceil(arg0: any) -> int;
    fn check_old_code(arg0: any) -> bool;
    fn check_process_code(arg0: any, arg1: any) -> any;
    fn check_process_code(arg0: any, arg1: any, arg2: any) -> any;
    fn crc32(arg0: any) -> int;
    fn crc32(arg0: any, arg1: any) -> int;
    fn crc32_combine(arg0: any, arg1: any, arg2: any) -> int;
    fn date() -> any;
    fn decode_packet(arg0: any, arg1: any, arg2: any) -> any;
    fn delete_element(arg0: any, arg1: any) -> any;
    fn delete_module(arg0: any) -> any;
    fn demonitor(arg0: any) -> atom;
    fn demonitor(arg0: any, arg1: any) -> bool;
    fn alias() -> any;
    fn alias(arg0: any) -> any;
    fn unalias(arg0: any) -> bool;
    fn display(arg0: any) -> atom;
    fn display_string(arg0: any) -> atom;
    fn display_string(arg0: any, arg1: any) -> atom;
    fn dt_append_vm_tag_data(arg0: any) -> any;
    fn dt_get_tag() -> any;
    fn dt_get_tag_data() -> any;
    fn dt_prepend_vm_tag_data(arg0: any) -> any;
    fn dt_put_tag(arg0: any) -> any;
    fn dt_restore_tag(arg0: any) -> atom;
    fn dt_spread_tag(arg0: any) -> any;
    fn erase() -> [(any, any)];
    fn erase(arg0: any) -> any;
    fn error(arg0: any) -> any;
    fn error(arg0: any, arg1: any) -> any;
    fn error(arg0: any, arg1: any, arg2: any) -> any;
    fn exit(arg0: any) -> any;
    fn exit(arg0: any, arg1: any) -> atom;
    fn exit_signal(arg0: any, arg1: any) -> atom;
    fn external_size(arg0: any) -> int;
    fn external_size(arg0: any, arg1: any) -> int;
    fn finish_loading(arg0: any) -> any;
    fn finish_after_on_load(arg0: any, arg1: any) -> atom;
    fn float(arg0: any) -> float;
    fn float_to_binary(arg0: any) -> binary;
    fn float_to_binary(arg0: any, arg1: any) -> binary;
    fn float_to_list(arg0: any) -> string;
    fn float_to_list(arg0: any, arg1: any) -> string;
    fn floor(arg0: any) -> int;
    fn fun_info(arg0: any, arg1: any) -> (any, any);
    fn fun_info_mfa(arg0: any) -> (any, any, any);
    fn fun_to_list(arg0: any) -> string;
    fn function_exported(arg0: any, arg1: any, arg2: any) -> bool;
    fn garbage_collect() -> atom;
    fn garbage_collect(arg0: any) -> any;
    fn garbage_collect(arg0: any, arg1: any) -> any;
    fn garbage_collect_message_area() -> bool;
    fn get() -> [(any, any)];
    fn get(arg0: any) -> any;
    fn get_keys() -> [any];
    fn get_keys(arg0: any) -> [any];
    fn get_module_info(arg0: any) -> [(any, any)];
    fn group_leader() -> pid;
    fn group_leader(arg0: any, arg1: any) -> atom;
    fn halt() -> any;
    fn halt(arg0: any) -> any;
    fn halt(arg0: int, arg1: any, arg2: string, arg3: any) -> any;
    fn has_prepared_code_on_load(arg0: any) -> bool;
    fn hibernate(arg0: any, arg1: any, arg2: any) -> any;
    fn insert_element(arg0: any, arg1: any, arg2: any) -> any;
    fn integer_to_binary(arg0: any) -> binary;
    fn integer_to_list(arg0: any) -> string;
    fn iolist_size(arg0: any) -> int;
    fn iolist_to_binary(arg0: any) -> binary;
    fn iolist_to_iovec(arg0: any) -> any;
    fn is_alive() -> bool;
    fn is_builtin(arg0: any, arg1: any, arg2: any) -> bool;
    fn is_map_key(arg0: any, arg1: any) -> bool;
    fn is_process_alive(arg0: any) -> bool;
    fn length(arg0: any) -> int;
    fn link(arg0: any) -> atom;
    fn list_to_atom(arg0: any) -> atom;
    fn list_to_binary(arg0: any) -> binary;
    fn list_to_bitstring(arg0: any) -> binary;
    fn list_to_existing_atom(arg0: any) -> atom;
    fn list_to_float(arg0: any) -> float;
    fn list_to_integer(arg0: any) -> int;
    fn list_to_integer(arg0: any, arg1: any) -> int;
    fn list_to_pid(arg0: any) -> pid;
    fn list_to_port(arg0: any) -> any;
    fn list_to_ref(arg0: any) -> ref;
    fn list_to_tuple(arg0: any) -> any;
    fn loaded() -> [any];
    fn localtime() -> any;
    fn make_ref() -> ref;
    fn map_size(arg0: any) -> int;
    fn map_get(arg0: any, arg1: any) -> any;
    fn match_spec_test(arg0: any, arg1: any, arg2: any) -> any;
    fn md5(arg0: any) -> any;
    fn md5_final(arg0: any) -> any;
    fn md5_init() -> any;
    fn md5_update(arg0: any, arg1: any) -> any;
    fn module_loaded(arg0: any) -> bool;
    fn monitor(arg0: any, arg1: any) -> any;
    fn monitor(arg0: any, arg1: any, arg2: [any]) -> any;
    fn monitor_node(arg0: any, arg1: any) -> atom;
    fn monitor_node(arg0: any, arg1: any, arg2: any) -> atom;
    fn nif_error(arg0: any) -> any;
    fn nif_error(arg0: any, arg1: any) -> any;
    fn node() -> any;
    fn node(arg0: any) -> any;
    fn now() -> any;
    fn phash(arg0: any, arg1: any) -> any;
    fn phash2(arg0: any) -> any;
    fn phash2(arg0: any, arg1: any) -> any;
    fn pid_to_list(arg0: any) -> string;
    fn port_to_list(arg0: any) -> string;
    fn ports() -> [any];
    fn posixtime_to_universaltime(arg0: any) -> (any, any);
    fn unique_integer(arg0: any) -> int;
    fn unique_integer() -> int;
    fn monotonic_time() -> int;
    fn monotonic_time(arg0: any) -> int;
    fn system_time() -> int;
    fn system_time(arg0: any) -> int;
    fn convert_time_unit(arg0: any, arg1: any, arg2: any) -> any;
    fn time_offset() -> int;
    fn time_offset(arg0: any) -> int;
    fn timestamp() -> any;
    fn prepare_loading(arg0: any, arg1: any) -> any;
    fn pre_loaded() -> [any];
    fn process_display(arg0: any, arg1: any) -> atom;
    fn process_flag(arg0: any, arg1: any, arg2: any) -> any;
    fn process_info(arg0: any) -> any;
    fn processes() -> [pid];
    fn purge_module(arg0: any) -> atom;
    fn put(arg0: any, arg1: any) -> any;
    fn raise(arg0: any, arg1: any, arg2: any) -> atom;
    fn read_timer(arg0: any) -> any;
    fn read_timer(arg0: any, arg1: any) -> any;
    fn ref_to_list(arg0: any) -> string;
    fn register(arg0: any, arg1: any) -> atom;
    fn registered() -> [any];
    fn resume_process(arg0: any) -> atom;
    fn round(arg0: any) -> int;
    fn self() -> pid;
    fn send_after(arg0: any, arg1: any, arg2: any) -> any;
    fn send_after(arg0: any, arg1: any, arg2: any, arg3: any) -> any;
    fn seq_trace(arg0: any, arg1: any) -> any;
    fn seq_trace_print(arg0: any) -> bool;
    fn seq_trace_print(arg0: any, arg1: any) -> bool;
    fn setnode(arg0: any, arg1: any) -> atom;
    fn setnode(arg0: any, arg1: any, arg2: any) -> any;
    fn size(arg0: any) -> int;
    fn spawn(arg0: any, arg1: any, arg2: any) -> pid;
    fn spawn_link(arg0: any, arg1: any, arg2: any) -> pid;
    fn split_binary(arg0: any, arg1: any) -> (binary, binary);
    fn start_timer(arg0: any, arg1: any, arg2: any) -> any;
    fn start_timer(arg0: any, arg1: any, arg2: any, arg3: any) -> any;
    fn suspend_process(arg0: any, arg1: any) -> bool;
    fn suspend_process(arg0: any) -> atom;
    fn system_monitor() -> any;
    fn system_monitor(arg0: any) -> any;
    fn system_monitor(arg0: any, arg1: any) -> any;
    fn system_profile() -> any;
    fn system_profile(arg0: any, arg1: any) -> any;
    fn throw(arg0: any) -> any;
    fn time() -> any;
    fn trace(arg0: any, arg1: any, arg2: any) -> int;
    fn trace_delivered(arg0: any) -> any;
    fn trace_info(arg0: any, arg1: any) -> any;
    fn trunc(arg0: any) -> int;
    fn tuple_size(arg0: any) -> int;
    fn universaltime() -> any;
    fn universaltime_to_posixtime(arg0: any) -> int;
    fn unlink(arg0: any) -> atom;
    fn unregister(arg0: any) -> atom;
    fn whereis(arg0: any) -> any;
    fn abs(arg0: any) -> float;
    fn append(arg0: any, arg1: any) -> any;
    fn element(arg0: any, arg1: any) -> any;
    fn get_module_info(arg0: any, arg1: any) -> any;
    fn hd(arg0: any) -> any;
    fn is_atom(arg0: any) -> bool;
    fn is_binary(arg0: any) -> bool;
    fn is_bitstring(arg0: any) -> bool;
    fn is_boolean(arg0: any) -> bool;
    fn is_float(arg0: any) -> bool;
    fn is_function(arg0: any) -> bool;
    fn is_function(arg0: any, arg1: any) -> bool;
    fn is_integer(arg0: any) -> bool;
    fn is_list(arg0: any) -> bool;
    fn is_number(arg0: any) -> bool;
    fn is_pid(arg0: any) -> bool;
    fn is_map(arg0: any) -> bool;
    fn is_port(arg0: any) -> bool;
    fn is_record(arg0: any, arg1: any) -> bool;
    fn is_record(arg0: any, arg1: any, arg2: any) -> bool;
    fn is_reference(arg0: any) -> bool;
    fn is_tuple(arg0: any) -> bool;
    fn load_module(arg0: any, arg1: any) -> any;
    fn load_nif(arg0: any, arg1: any) -> any;
    fn localtime_to_universaltime(arg0: any, arg1: any) -> any;
    fn make_fun(arg0: any, arg1: any, arg2: any) -> fn() -> any;
    fn make_tuple(arg0: any, arg1: any) -> any;
    fn make_tuple(arg0: any, arg1: any, arg2: any) -> any;
    fn open_port(arg0: any, arg1: any) -> any;
    fn process_flag(arg0: any, arg1: any) -> any;
    fn process_info(arg0: any, arg1: any) -> any;
    fn send(arg0: any, arg1: any) -> any;
    fn send(arg0: any, arg1: any, arg2: any) -> any;
    fn seq_trace_info(arg0: any, arg1: any, arg2: any, arg3: any, arg4: any, arg5: any, arg6: any, arg7: any) -> any;
    fn setelement(arg0: any, arg1: any, arg2: any) -> any;
    fn statistics(arg0: any) -> [any];
    fn subtract(arg0: [any], arg1: [any]) -> [any];
    fn system_flag(arg0: any, arg1: any) -> any;
    fn term_to_binary(arg0: any) -> any;
    fn term_to_binary(arg0: any, arg1: any) -> any;
    fn term_to_iovec(arg0: any) -> any;
    fn term_to_iovec(arg0: any, arg1: any) -> any;
    fn tl(arg0: any) -> any;
    fn trace_pattern(arg0: any, arg1: any) -> int;
    fn trace_pattern(arg0: any, arg1: any, arg2: [any]) -> int;
    fn tuple_to_list(arg0: any) -> [any];
    fn system_info(arg0: any) -> (any, any, any, any);
    fn universaltime_to_localtime(arg0: any) -> any;
    fn apply(arg0: any, arg1: any) -> any;
    fn apply(arg0: any, arg1: any, arg2: any) -> any;
    fn spawn(arg0: any) -> pid;
    fn spawn(arg0: any, arg1: any) -> pid;
    fn spawn_link(arg0: any) -> pid;
    fn spawn_link(arg0: any, arg1: any) -> pid;
    fn spawn_monitor(arg0: any) -> (pid, ref);
    fn spawn_monitor(arg0: any, arg1: any) -> (pid, ref);
    fn spawn_monitor(arg0: any, arg1: any, arg2: any) -> (pid, ref);
    fn spawn_opt(arg0: any, arg1: any) -> any;
    fn spawn_opt(arg0: any, arg1: any, arg2: any) -> any;
    fn spawn(arg0: any, arg1: any, arg2: any, arg3: any) -> pid;
    fn spawn_link(arg0: any, arg1: any, arg2: any, arg3: any) -> pid;
    fn spawn_monitor(arg0: any, arg1: any, arg2: any, arg3: any) -> (pid, ref);
    fn spawn_opt(arg0: any, arg1: any, arg2: any, arg3: any) -> any;
    fn spawn_opt(arg0: any, arg1: any, arg2: any, arg3: any, arg4: any) -> any;
    fn spawn_request(arg0: any) -> any;
    fn spawn_request(arg0: any, arg1: any) -> any;
    fn spawn_request(arg0: any, arg1: any, arg2: any) -> any;
    fn spawn_request(arg0: any, arg1: any, arg2: any, arg3: any) -> any;
    fn spawn_request(arg0: any, arg1: any, arg2: any, arg3: any, arg4: any) -> any;
    fn spawn_request_abandon(arg0: any) -> bool;
    fn yield() -> atom;
    fn nodes() -> any;
    fn nodes(arg0: any) -> any;
    fn nodes(arg0: any, arg1: any) -> [any];
    fn disconnect_node(arg0: any) -> any;
    fn fun_info(arg0: any) -> [(any, any)];
    fn send_nosuspend(arg0: any, arg1: any) -> bool;
    fn send_nosuspend(arg0: any, arg1: any, arg2: any) -> bool;
    fn localtime_to_universaltime(arg0: any) -> any;
    fn port_command(arg0: any, arg1: any) -> atom;
    fn port_command(arg0: any, arg1: any, arg2: any) -> bool;
    fn port_connect(arg0: any, arg1: any) -> atom;
    fn port_close(arg0: any) -> atom;
    fn port_control(arg0: any, arg1: any, arg2: any) -> any;
    fn port_call(arg0: any, arg1: any) -> any;
    fn port_call(arg0: any, arg1: any, arg2: any) -> any;
    fn port_info(arg0: any) -> any;
    fn port_info(arg0: any, arg1: any) -> any;
    fn port_set_data(arg0: any, arg1: any) -> atom;
    fn port_get_data(arg0: any) -> any;
    fn dist_ctrl_input_handler(arg0: any, arg1: any) -> atom;
    fn dist_ctrl_put_data(arg0: any, arg1: any) -> atom;
    fn dist_ctrl_get_data(arg0: any) -> any;
    fn dist_ctrl_get_data_notification(arg0: any) -> atom;
    fn dist_ctrl_set_opt(arg0: any, arg1: atom, arg2: any) -> any;
    fn dist_ctrl_get_opt(arg0: any, arg1: atom) -> any;
    fn dist_get_stat(arg0: any) -> any;
    fn delay_trap(arg0: any, arg1: any) -> any;
    fn set_cookie(arg0: any) -> atom;
    fn set_cookie(arg0: any, arg1: any) -> atom;
    fn get_cookie() -> any;
    fn get_cookie(arg0: any) -> any;
    fn integer_to_list(arg0: any, arg1: any) -> string;
    fn integer_to_binary(arg0: any, arg1: any) -> binary;
    fn min(arg0: any, arg1: any) -> any;
    fn max(arg0: any, arg1: any) -> any;
    fn memory() -> [(any, any)];
    fn memory(arg0: [any]) -> [(any, int)];
    fn gather_gc_info_result(arg0: any) -> (int, int, any);
}

