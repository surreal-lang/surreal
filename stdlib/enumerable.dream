// Dream Standard Library - Enum Module
//
// Provides functional collection operations for lists and other enumerables.
// Inspired by Elixir's Enum module.

use erlang::std::lists as erl_lists;
use erlang::std::erlang as erl;
use erlang::std::maps as erl_maps;
use erlang::std::rand as erl_rand;

// =============================================================================
// Iter Trait
// =============================================================================

/// Trait for iterable collections.
///
/// Types implementing Iter provide enumerable operations as methods,
/// allowing a fluent interface: `my_map.filter(...).map(...)`
///
/// For lists, use the module functions: `enumerable::map(list, f)`
/// For Iter types, use method syntax: `my_map.map(f)`
///
/// Required:
///   fn to_list(self) - Convert to a list
///
/// Recommended methods to implement in impl block:
///   fn map(self, f) - Transform each element
///   fn filter(self, pred) - Keep matching elements
///   fn reduce(self, init, f) - Fold to a single value
///   fn any(self, pred) - Check if any match
///   fn all(self, pred) - Check if all match
///   fn count(self, pred) - Count matches
///   fn take(self, n) - First n elements
///   fn drop(self, n) - Skip first n elements
///   fn reverse(self) - Reverse order
///
/// Example:
///   let seniors = people_map.filter(|e| { e.age > 30 });
///   let names = seniors.map(|e| { e.name });
trait Iter {
    /// Convert to a list for iteration.
    fn to_list(self);
}

// =============================================================================
// Core Transformations
// =============================================================================

/// Transform each element using a function.
pub fn map<T, U>(items: [T], f: fn(T) -> U) -> [U] {
    erl_lists::map(f, items)
}

/// Keep only elements where the predicate returns true.
pub fn filter<T>(items: [T], pred: fn(T) -> bool) -> [T] {
    erl_lists::filter(pred, items)
}

/// Remove elements where the predicate returns true.
pub fn reject<T>(items: [T], pred: fn(T) -> bool) -> [T] {
    // Can't use nested closure with outer param, use filtermap
    erl_lists::filtermap(|x| {
        if pred(x) {
            false
        } else {
            (true, x)
        }
    }, items)
}

/// Reduce a list to a single value using an accumulator.
pub fn reduce<T, Acc>(items: [T], init: Acc, f: fn(T, Acc) -> Acc) -> Acc {
    erl_lists::foldl(f, init, items)
}

/// Reduce from the right side.
pub fn reduce_right<T, Acc>(items: [T], init: Acc, f: fn(T, Acc) -> Acc) -> Acc {
    erl_lists::foldr(f, init, items)
}

/// Map then flatten one level.
pub fn flat_map<T, U>(items: [T], f: fn(T) -> [U]) -> [U] {
    erl_lists::flatmap(f, items)
}

// =============================================================================
// Searching and Finding
// =============================================================================

/// Find the first element matching the predicate.
pub fn find<T>(items: [T], pred: fn(T) -> bool) -> Option<T> {
    find_in_list(items, pred)
}

fn find_in_list<T>(items: [T], pred: fn(T) -> bool) -> Option<T> {
    match items {
        [] => None,
        [head | tail] => {
            if pred(head) {
                Some(head)
            } else {
                find_in_list(tail, pred)
            }
        }
    }
}

/// Check if any element matches the predicate.
pub fn any<T>(items: [T], pred: fn(T) -> bool) -> bool {
    erl_lists::any(pred, items)
}

/// Check if all elements match the predicate.
pub fn all<T>(items: [T], pred: fn(T) -> bool) -> bool {
    erl_lists::all(pred, items)
}

/// Check if no elements match the predicate.
pub fn none<T>(items: [T], pred: fn(T) -> bool) -> bool {
    !erl_lists::any(pred, items)
}

/// Count elements matching a predicate.
pub fn count<T>(items: [T], pred: fn(T) -> bool) -> int {
    erl::length(erl_lists::filter(pred, items))
}

/// Count all elements.
pub fn count_all<T>(items: [T]) -> int {
    erl::length(items)
}

/// Check if an element exists in the list.
pub fn member<T>(items: [T], elem: T) -> bool {
    erl_lists::member(elem, items)
}

// =============================================================================
// Slicing and Subsetting
// =============================================================================

/// Take the first n elements.
pub fn take<T>(items: [T], n: int) -> [T] {
    erl_lists::sublist(items, n)
}

/// Drop the first n elements.
pub fn drop<T>(items: [T], n: int) -> [T] {
    erl_lists::nthtail(n, items)
}

/// Take elements while predicate is true.
pub fn take_while<T>(items: [T], pred: fn(T) -> bool) -> [T] {
    erl_lists::takewhile(pred, items)
}

/// Drop elements while predicate is true.
pub fn drop_while<T>(items: [T], pred: fn(T) -> bool) -> [T] {
    erl_lists::dropwhile(pred, items)
}

/// Get a slice from start index with given length.
pub fn slice<T>(items: [T], start: int, len: int) -> [T] {
    erl_lists::sublist(items, start + 1, len)
}

/// Split a list at position n.
pub fn split<T>(items: [T], n: int) -> ([T], [T]) {
    erl_lists::split(n, items)
}

/// Split a list based on a predicate (take_while, drop_while combined).
pub fn split_while<T>(items: [T], pred: fn(T) -> bool) -> ([T], [T]) {
    erl_lists::splitwith(pred, items)
}

// =============================================================================
// Combining and Splitting
// =============================================================================

/// Zip two lists into a list of tuples.
pub fn zip<A, B>(a: [A], b: [B]) -> [(A, B)] {
    erl_lists::zip(a, b)
}

/// Zip with a custom combining function.
pub fn zip_with<A, B, C>(a: [A], b: [B], f: fn(A, B) -> C) -> [C] {
    erl_lists::zipwith(f, a, b)
}

/// Unzip a list of tuples into two lists.
pub fn unzip<A, B>(items: [(A, B)]) -> ([A], [B]) {
    erl_lists::unzip(items)
}

/// Concatenate a list of lists.
pub fn concat<T>(items: [[T]]) -> [T] {
    erl_lists::append(items)
}

/// Intersperse an element between all elements.
pub fn intersperse<T>(items: [T], sep: T) -> [T] {
    intersperse_loop(items, sep)
}

fn intersperse_loop<T>(items: [T], sep: T) -> [T] {
    match items {
        [] => [],
        [x] => [x],
        [x | rest] => erl_lists::append([x, sep], intersperse_loop(rest, sep)),
    }
}

/// Chunk a list into sublists of size n.
pub fn chunk<T>(items: [T], n: int) -> [[T]] {
    chunk_loop(items, n, [])
}

fn chunk_loop<T>(items: [T], n: int, acc: [[T]]) -> [[T]] {
    if erl::length(items) == 0 {
        erl_lists::reverse(acc)
    } else {
        let chunk = erl_lists::sublist(items, n);
        let rest = if erl::length(items) > n {
            erl_lists::nthtail(n, items)
        } else {
            []
        };
        chunk_loop(rest, n, erl_lists::append([chunk], acc))
    }
}

// =============================================================================
// Sorting and Ordering
// =============================================================================

/// Sort a list using default comparison.
pub fn sort<T>(items: [T]) -> [T] {
    erl_lists::sort(items)
}

/// Sort a list using a custom comparison function.
/// The function should return true if the first arg should come before the second.
pub fn sort_by<T>(items: [T], cmp: fn(T, T) -> bool) -> [T] {
    erl_lists::sort(cmp, items)
}

/// Reverse a list.
pub fn reverse<T>(items: [T]) -> [T] {
    erl_lists::reverse(items)
}

/// Shuffle a list randomly.
pub fn shuffle<T>(items: [T]) -> [T] {
    // Fisher-Yates shuffle using Erlang's random
    let indexed = erl_lists::zip(erl_lists::seq(1, erl::length(items)), items);
    let shuffled = erl_lists::sort(|a, b| { erl_rand::uniform(100) < 50 }, indexed);
    map(shuffled, |pair| { erl::element(2, pair) })
}

// =============================================================================
// Uniqueness and Grouping
// =============================================================================

/// Remove duplicate elements (keeps first occurrence).
pub fn uniq<T>(items: [T]) -> [T] {
    erl_lists::usort(items)
}

/// Remove consecutive duplicate elements.
pub fn dedup<T>(items: [T]) -> [T] {
    if erl::length(items) < 2 {
        items
    } else {
        dedup_loop(items, erl::hd(items), [erl::hd(items)])
    }
}

fn dedup_loop<T>(items: [T], prev: T, acc: [T]) -> [T] {
    let rest = erl::tl(items);
    if erl::length(rest) == 0 {
        erl_lists::reverse(acc)
    } else {
        let curr = erl::hd(rest);
        if curr == prev {
            dedup_loop(rest, curr, acc)
        } else {
            dedup_loop(rest, curr, erl_lists::append([curr], acc))
        }
    }
}

/// Group elements by a key function.
pub fn group_by<T, K>(items: [T], key_fn: fn(T) -> K) -> Map {
    reduce(items, erl_maps::new(), |item, acc| {
        let key = key_fn(item);
        let existing = erl_maps::get(key, acc, []);
        erl_maps::put(key, erl_lists::append([item], existing), acc)
    })
}

/// Partition elements into two lists based on a predicate.
pub fn partition<T>(items: [T], pred: fn(T) -> bool) -> ([T], [T]) {
    erl_lists::partition(pred, items)
}

// =============================================================================
// Aggregation
// =============================================================================

/// Sum all numbers.
pub fn sum(items: [int]) -> int {
    erl_lists::sum(items)
}

/// Sum using a function to extract the value.
pub fn sum_by<T>(items: [T], f: fn(T) -> int) -> int {
    reduce(items, 0, |item, acc| { acc + f(item) })
}

/// Find the maximum value.
pub fn max<T>(items: [T]) -> T {
    erl_lists::max(items)
}

/// Find the minimum value.
pub fn min<T>(items: [T]) -> T {
    erl_lists::min(items)
}

/// Find the maximum by a custom comparison.
pub fn max_by<T>(items: [T], f: fn(T) -> int) -> T {
    reduce(erl::tl(items), erl::hd(items), |item, best| {
        if f(item) > f(best) {
            item
        } else {
            best
        }
    })
}

/// Find the minimum by a custom comparison.
pub fn min_by<T>(items: [T], f: fn(T) -> int) -> T {
    reduce(erl::tl(items), erl::hd(items), |item, best| {
        if f(item) < f(best) {
            item
        } else {
            best
        }
    })
}

// =============================================================================
// Iteration
// =============================================================================

/// Apply a function to each element for side effects.
pub fn each<T>(items: [T], f: fn(T) -> ()) {
    let _ = erl_lists::foreach(f, items);
}

/// Apply a function to each element with its index.
pub fn each_with_index<T>(items: [T], f: fn(T, int) -> ()) {
    each_with_index_loop(items, 0, f);
}

fn each_with_index_loop<T>(items: [T], idx: int, f: fn(T, int) -> ()) {
    match items {
        [] => (),
        [head | tail] => {
            let _ = f(head, idx);
            each_with_index_loop(tail, idx + 1, f)
        }
    }
}

/// Map with index.
pub fn map_with_index<T, U>(items: [T], f: fn(T, int) -> U) -> [U] {
    let indexed = erl_lists::zip(erl_lists::seq(0, erl::length(items) - 1), items);
    map(indexed, |pair| { f(erl::element(2, pair), erl::element(1, pair)) })
}

// =============================================================================
// Predicates
// =============================================================================

/// Check if the list is empty.
pub fn is_empty<T>(items: [T]) -> bool {
    items == []
}

/// Get the first element if it exists.
pub fn first<T>(items: [T]) -> Option<T> {
    match items {
        [] => None,
        [head | _] => Some(head),
    }
}

/// Get the last element if it exists.
pub fn last<T>(items: [T]) -> Option<T> {
    match items {
        [] => None,
        _ => Some(erl_lists::last(items)),
    }
}

/// Get element at index if it exists.
pub fn at<T>(items: [T], index: int) -> Option<T> {
    if index < 0 {
        None
    } else if index >= erl::length(items) {
        None
    } else {
        Some(erl_lists::nth(index + 1, items))
    }
}

// =============================================================================
// Creation
// =============================================================================

/// Create a list with n copies of an element.
pub fn replicate<T>(n: int, elem: T) -> [T] {
    erl_lists::duplicate(n, elem)
}

/// Create a range of integers.
pub fn range(start: int, stop: int) -> [int] {
    erl_lists::seq(start, stop)
}

/// Create a range with a step.
pub fn range_step(start: int, stop: int, step: int) -> [int] {
    erl_lists::seq(start, stop, step)
}
