// Dream Standard Library - Option Module
//
// Provides the Option<T> type for representing optional values.

/// Option type - represents a value that may or may not exist.
pub enum Option<T> {
    Some(T),
    None,
}

/// Check if the option contains a value.
pub fn is_some<T>(opt: Option<T>) -> bool {
    match opt {
        Some(_) => true,
        None => false,
    }
}

/// Check if the option is empty.
pub fn is_none<T>(opt: Option<T>) -> bool {
    match opt {
        Some(_) => false,
        None => true,
    }
}

/// Unwrap the option, returning the contained value.
/// Panics if the option is None.
pub fn unwrap<T>(opt: Option<T>) -> T {
    match opt {
        Some(x) => x,
        None => :erlang::error(:unwrap_none),
    }
}

/// Unwrap the option, returning a default value if None.
pub fn unwrap_or<T>(opt: Option<T>, default: T) -> T {
    match opt {
        Some(x) => x,
        None => default,
    }
}

/// Unwrap the option, calling a function to produce a default if None.
pub fn unwrap_or_else<T>(opt: Option<T>, f: Fn) -> T {
    match opt {
        Some(x) => x,
        None => f(),
    }
}

/// Map a function over the contained value.
pub fn map<T, U>(opt: Option<T>, f: Fn) -> Option<U> {
    match opt {
        Some(x) => Some(f(x)),
        None => None,
    }
}

/// Map a function over the contained value, returning a default if None.
pub fn map_or<T, U>(opt: Option<T>, default: U, f: Fn) -> U {
    match opt {
        Some(x) => f(x),
        None => default,
    }
}

/// Apply a function that returns an Option to the contained value.
pub fn and_then<T, U>(opt: Option<T>, f: Fn) -> Option<U> {
    match opt {
        Some(x) => f(x),
        None => None,
    }
}

/// Return the option if it contains a value, otherwise return the other option.
pub fn or<T>(opt: Option<T>, other: Option<T>) -> Option<T> {
    match opt {
        Some(x) => Some(x),
        None => other,
    }
}

/// Return the option if it contains a value, otherwise call the function.
pub fn or_else<T>(opt: Option<T>, f: Fn) -> Option<T> {
    match opt {
        Some(x) => Some(x),
        None => f(),
    }
}

/// Filter the option based on a predicate.
pub fn filter<T>(opt: Option<T>, predicate: Fn) -> Option<T> {
    match opt {
        Some(x) => {
            if predicate(x) {
                Some(x)
            } else {
                None
            }
        }
        None => None,
    }
}

/// Convert an Option to a list (empty list for None, single-element list for Some).
pub fn to_list<T>(opt: Option<T>) -> [T] {
    match opt {
        Some(x) => [x],
        None => [],
    }
}
