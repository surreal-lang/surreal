// Surreal Standard Library - List Module
//
// Provides list manipulation functions.

use erlang::std::lists as erl_lists;
use erlang::std::erlang as erl;

/// Reverse a list.
pub fn reverse<T>(items: [T]) -> [T] {
    erl_lists::reverse(items)
}

/// Get the length of a list.
pub fn len<T>(items: [T]) -> int {
    erl::length(items)
}

/// Get the first element of a list.
pub fn head<T>(items: [T]) -> T {
    erl::hd(items)
}

/// Get all elements except the first.
pub fn tail<T>(items: [T]) -> [T] {
    erl::tl(items)
}

/// Append two lists.
pub fn append<T>(a: [T], b: [T]) -> [T] {
    erl_lists::append(a, b)
}

/// Flatten a list of lists.
pub fn flatten<T>(items: [[T]]) -> [T] {
    erl_lists::flatten(items)
}

/// Sort a list.
pub fn sort<T>(items: [T]) -> [T] {
    erl_lists::sort(items)
}

/// Get the nth element (1-indexed, like Erlang).
pub fn nth<T>(n: int, items: [T]) -> T {
    erl_lists::nth(n, items)
}

/// Check if an element is in the list.
pub fn member<T>(elem: T, items: [T]) -> bool {
    erl_lists::member(elem, items)
}

/// Get the last element of a list.
pub fn last<T>(items: [T]) -> T {
    erl_lists::last(items)
}

/// Take the first n elements.
pub fn take<T>(n: int, items: [T]) -> [T] {
    erl_lists::sublist(items, n)
}

/// Drop the first n elements.
pub fn drop<T>(n: int, items: [T]) -> [T] {
    erl_lists::nthtail(n, items)
}

/// Zip two lists into a list of tuples.
pub fn zip<A, B>(a: [A], b: [B]) -> [(A, B)] {
    erl_lists::zip(a, b)
}

/// Unzip a list of tuples into two lists.
pub fn unzip<A, B>(items: [(A, B)]) -> ([A], [B]) {
    erl_lists::unzip(items)
}

/// Sum all integers in a list.
pub fn sum(items: [int]) -> int {
    erl_lists::sum(items)
}

/// Find the maximum value in a list.
pub fn max(items: [int]) -> int {
    erl_lists::max(items)
}

/// Find the minimum value in a list.
pub fn min(items: [int]) -> int {
    erl_lists::min(items)
}

/// Check if a list is empty.
pub fn is_empty<T>(items: [T]) -> bool {
    erl::length(items) == 0
}

/// Create a list with n copies of an element.
pub fn replicate<T>(n: int, elem: T) -> [T] {
    erl_lists::duplicate(n, elem)
}

/// Create a range of integers from start to end (inclusive).
pub fn range(start: int, stop: int) -> [int] {
    erl_lists::seq(start, stop)
}
