// Dream Standard Library - File Module
//
// File system operations with Elixir-style ergonomics.
// All functions take path as first argument for pipe compatibility.
// Returns (:ok, result) or (:error, reason) tuples.

// ============== Read Operations ==============

/// Read entire file contents as binary.
/// Returns Ok(binary) or Err(reason).
pub fn read(path: any) -> Result<any, any> {
    :file::read_file(path)
}

/// Read file and split into lines.
/// Returns Ok([lines]) or Err(reason).
pub fn read_lines(path: any) -> Result<any, any> {
    match :file::read_file(path) {
        Ok(content) => {
            let lines = :binary::split(content, <<"\n">>, [:global]);
            Ok(lines)
        },
        Err(e) => Err(e)
    }
}

// ============== Write Operations ==============

/// Write content to file, creating if it doesn't exist.
/// Returns :ok or (:error, reason).
pub fn write(path: any, content: any) -> any {
    :file::write_file(path, content)
}

/// Write content with specific modes.
/// Modes: [:append, :binary, :raw, etc.]
pub fn write_with_modes(path: any, content: any, modes: [any]) -> any {
    :file::write_file(path, content, modes)
}

/// Append content to file.
/// Returns :ok or (:error, reason).
pub fn append(path: any, content: any) -> any {
    :file::write_file(path, content, [:append])
}

// ============== File Information ==============

/// Check if path exists.
pub fn exists(path: any) -> bool {
    if :filelib::is_file(path) {
        true
    } else {
        :filelib::is_dir(path)
    }
}

/// Check if path is a regular file.
pub fn regular(path: any) -> bool {
    :filelib::is_regular(path)
}

/// Check if path is a directory.
pub fn dir(path: any) -> bool {
    :filelib::is_dir(path)
}

/// Get file statistics.
/// Returns Ok(stat_info) or Err(reason).
pub fn stat(path: any) -> Result<any, any> {
    :file::read_file_info(path)
}

/// Get file size in bytes.
/// Returns Ok(size) or Err(reason).
pub fn size(path: any) -> Result<any, any> {
    match :file::read_file_info(path) {
        Ok(info) => {
            let file_size = :erlang::element(2, info);
            Ok(file_size)
        },
        Err(e) => Err(e)
    }
}

// ============== Directory Operations ==============

/// Create a directory.
/// Returns :ok or (:error, reason).
pub fn mkdir(path: any) -> any {
    :file::make_dir(path)
}

/// Create a directory and all parent directories.
/// Returns :ok or (:error, reason).
pub fn mkdir_p(path: any) -> any {
    :filelib::ensure_dir(:filename::join(path, "dummy"))
}

/// Remove an empty directory.
/// Returns :ok or (:error, reason).
pub fn rmdir(path: any) -> any {
    :file::del_dir(path)
}

/// List directory contents.
/// Returns Ok([filenames]) or Err(reason).
pub fn ls(path: any) -> Result<any, any> {
    match :file::list_dir(path) {
        Ok(files) => {
            // Convert charlists to binaries
            let binaries = :lists::map(|f| { :erlang::list_to_binary(f) }, files);
            Ok(binaries)
        },
        Err(e) => Err(e)
    }
}

// ============== File Management ==============

/// Copy a file.
/// Returns Ok(bytes_copied) or Err(reason).
pub fn cp(source: any, destination: any) -> Result<any, any> {
    :file::copy(source, destination)
}

/// Rename/move a file or directory.
/// Returns :ok or (:error, reason).
pub fn rename(source: any, destination: any) -> any {
    :file::rename(source, destination)
}

/// Delete a file.
/// Returns :ok or (:error, reason).
pub fn rm(path: any) -> any {
    :file::delete(path)
}

/// Recursively delete files and directories.
/// Returns :ok or Err(reason).
pub fn rm_rf(path: any) -> any {
    // Check if it's a directory
    if dir(path) {
        // List and delete contents first
        match ls(path) {
            Ok(files) => {
                let results = :lists::map(|f| {
                    let full_path = :filename::join(path, f);
                    rm_rf(full_path)
                }, files);
                // Then delete the directory itself
                rmdir(path)
            },
            Err(e) => Err(e)
        }
    } else {
        // It's a file, just delete it
        rm(path)
    }
}

// ============== Working Directory ==============

/// Get current working directory.
/// Returns Ok(path) or Err(reason).
pub fn cwd() -> Result<any, any> {
    match :file::get_cwd() {
        Ok(dir) => Ok(:erlang::list_to_binary(dir)),
        Err(e) => Err(e)
    }
}

/// Change current working directory.
/// Returns :ok or (:error, reason).
pub fn cd(path: any) -> any {
    :file::set_cwd(path)
}

// ============== Permissions ==============

/// Change file permissions.
/// Mode is an integer (e.g., 0o755).
/// Returns :ok or (:error, reason).
pub fn chmod(path: any, mode: int) -> any {
    :file::change_mode(path, mode)
}

// ============== Links ==============

/// Create a symbolic link.
/// Returns :ok or (:error, reason).
pub fn ln_s(existing: any, new: any) -> any {
    :file::make_symlink(existing, new)
}

/// Create a hard link.
/// Returns :ok or (:error, reason).
pub fn ln(existing: any, new: any) -> any {
    :file::make_link(existing, new)
}

/// Read the target of a symbolic link.
/// Returns Ok(target) or Err(reason).
pub fn read_link(path: any) -> Result<any, any> {
    match :file::read_link(path) {
        Ok(target) => Ok(:erlang::list_to_binary(target)),
        Err(e) => Err(e)
    }
}

// ============== Touch ==============

/// Update file access and modification times.
/// Creates the file if it doesn't exist.
/// Returns :ok or (:error, reason).
pub fn touch(path: any) -> any {
    if exists(path) {
        // Update times to now
        let now = :erlang::localtime();
        :file::change_time(path, now)
    } else {
        // Create empty file
        write(path, <<>>)
    }
}

// ============== Open/Close (low-level) ==============

/// Open a file with specified modes.
/// Modes: [:read, :write, :append, :binary, :raw, etc.]
/// Returns Ok(io_device) or Err(reason).
pub fn open(path: any, modes: [any]) -> Result<any, any> {
    :file::open(path, modes)
}

/// Close an open file.
/// Returns :ok or (:error, reason).
pub fn close(io_device: any) -> any {
    :file::close(io_device)
}
