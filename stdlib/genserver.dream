// Dream Standard Library - GenServer Module
//
// A behaviour module for implementing the server of a client-server relation.
// Based on Erlang/OTP's gen_server and Elixir's GenServer.
//
// This implementation is OTP-compatible, using the same tuple formats
// as Erlang's gen_server for callback return values.

use erlang::std::erlang as erl;

// ============== Callback Return Types ==============
//
// init/1 returns:
//   (:ok, state)           - Start with initial state
//   (:ok, state, timeout)  - Start with timeout
//   :ignore                - Don't start, silently ignore
//   (:stop, reason)        - Don't start, stop with reason
//
// handle_call/3 returns:
//   (:reply, reply, new_state)
//   (:reply, reply, new_state, timeout)
//   (:noreply, new_state)
//   (:noreply, new_state, timeout)
//   (:stop, reason, reply, new_state)
//   (:stop, reason, new_state)
//
// handle_cast/2 and handle_info/2 return:
//   (:noreply, new_state)
//   (:noreply, new_state, timeout)
//   (:stop, reason, new_state)
//
// Note: The "from" value in handle_call is a From struct containing (pid, ref).
// Use genserver::reply(from, msg) to send a reply.

// ============== From Struct ==============

/// Represents the caller of a synchronous call.
/// Contains the pid and reference needed to send a reply.
pub struct From {
    pid: Pid,
    ref: Ref,
}

// ============== GenServer Trait ==============

/// The GenServer trait.
/// Implement this trait to create a stateful server process.
///
/// Required callbacks:
///   - init/1: Initialize server state
///   - handle_call/3: Handle synchronous calls
///   - handle_cast/2: Handle asynchronous casts
///
/// Optional callbacks (have default implementations):
///   - handle_info/2: Handle other messages (default: ignores message)
///   - terminate/2: Cleanup on shutdown (default: returns :ok)
pub trait GenServer {
    /// The server's state type
    type State;
    /// Message type for synchronous calls
    type CallMsg;
    /// Message type for asynchronous casts
    type CastMsg;
    /// Message type for other messages (info)
    type Info;

    /// Initialize the server state.
    /// Called when the server starts.
    /// Return (:ok, state) to start, :ignore to silently stop,
    /// or (:stop, reason) to stop with error.
    fn init(args: Any) -> (Atom, Self::State);

    /// Handle a synchronous call.
    /// `from` is a From struct - use genserver::reply(from, msg) to reply.
    /// Return (:reply, response, new_state) to reply immediately,
    /// (:noreply, new_state) to reply later via genserver::reply/2,
    /// or (:stop, reason, response, new_state) to stop the server.
    fn handle_call(msg: Self::CallMsg, from: From, state: Self::State) -> (Atom, any, Self::State);

    /// Handle an asynchronous cast.
    /// Return (:noreply, new_state) to continue,
    /// or (:stop, reason, new_state) to stop the server.
    fn handle_cast(msg: Self::CastMsg, state: Self::State) -> (Atom, Self::State);

    /// Handle any other message (optional).
    /// Default implementation ignores the message and continues with unchanged state.
    fn handle_info(_msg: Self::Info, state: Self::State) -> (Atom, Self::State) {
        // Default: ignore the message, keep state unchanged
        (:noreply, state)
    }

    /// Called when the server is about to terminate (optional).
    /// Use this for cleanup. Default implementation does nothing.
    fn terminate(_reason: Atom, _state: Self::State) -> Atom {
        // Default: do nothing
        :ok
    }
}

// ============== Client API ==============

/// Make a synchronous call to a GenServer.
/// Waits for a reply from the server.
pub fn call(server: Pid, msg: Any) -> Any {
    let ref = erl::make_ref();
    let from = (self(), ref);
    process::send(server, (:gen_call, from, msg));
    receive {
        (r, response) if r == ref => response
    }
}

/// Make a synchronous call with timeout (in milliseconds).
/// Returns (:ok, reply) on success, (:error, :timeout) on timeout.
pub fn call_timeout(server: Pid, msg: Any, timeout: int) -> (Atom, Any) {
    let ref = erl::make_ref();
    let from = (self(), ref);
    process::send(server, (:gen_call, from, msg));
    receive {
        (r, response) if r == ref => (:ok, response),
        after timeout => {
            (:error, :timeout)
        }
    }
}

/// Send an asynchronous cast to a GenServer.
/// Returns immediately without waiting for a reply.
pub fn cast(server: Pid, msg: Any) {
    process::send(server, (:gen_cast, msg));
}

/// Reply to a call from within a handler.
/// Useful for async replies when you don't reply in handle_call.
pub fn reply(from: From, msg: Any) {
    process::send(from.pid, (from.ref, msg));
}

/// Stop a GenServer gracefully.
pub fn stop(server: Pid) {
    // Send a cast with :stop message
    cast(server, :stop);
}

/// Stop a GenServer with a specific reason.
pub fn stop_reason(server: Pid, reason: Atom) {
    cast(server, (:stop, reason));
}

// ============== Server API ==============

/// Start a GenServer using dynamic dispatch (module-based).
/// The module must implement the GenServer trait (have init, handle_call, handle_cast functions).
pub fn start(module: Atom, args: Any) -> Pid {
    spawn || {
        let init_result = erl::apply(module, :init, [args]);
        match init_result {
            (:ok, state) => server_loop(module, state),
            :ignore => :ignore,
            (:stop, reason) => erl::exit(reason),
            _ => erl::exit(:bad_init_result)
        }
    }
}

// ============== Typed Server API (with trait bounds) ==============

/// Start a GenServer using static dispatch (type-based).
/// Uses monomorphization to call trait methods at compile time.
/// This provides type safety - the compiler verifies T implements GenServer.
pub fn start_typed<T: GenServer>(args: Any) -> Pid {
    spawn || {
        let init_result = GenServer::init::<T>(args);
        match init_result {
            (:ok, state) => server_loop_typed::<T>(state),
            :ignore => :ignore,
            (:stop, reason) => erl::exit(reason),
            _ => erl::exit(:bad_init_result)
        }
    }
}

/// Start a linked GenServer using static dispatch.
/// Links the calling process to the new server process.
pub fn start_link_typed<T: GenServer>(args: Any) -> Pid {
    let caller = process::current();
    spawn || {
        // Link to the caller before running init
        process::link(caller);
        let init_result = GenServer::init::<T>(args);
        match init_result {
            (:ok, state) => server_loop_typed::<T>(state),
            :ignore => :ignore,
            (:stop, reason) => erl::exit(reason),
            _ => erl::exit(:bad_init_result)
        }
    }
}

/// The typed server loop using static dispatch.
fn server_loop_typed<T: GenServer>(state: Any) -> Atom {
    receive {
        // Call protocol: {:gen_call, {pid, ref}, request}
        (:gen_call, (from_pid, from_ref), msg) => {
            let from = From { pid: from_pid, ref: from_ref };
            let result = GenServer::handle_call::<T>(msg, from, state);
            match result {
                (:reply, response, new_state) => {
                    reply(from, response);
                    server_loop_typed::<T>(new_state)
                },
                (:noreply, new_state) => {
                    server_loop_typed::<T>(new_state)
                },
                (:stop, reason, response, new_state) => {
                    reply(from, response);
                    let _ = terminate_typed::<T>(new_state, reason);
                    :ok
                },
                _ => server_loop_typed::<T>(state)
            }
        },
        // Cast protocol: {:gen_cast, request}
        (:gen_cast, msg) => {
            // Handle special :stop message
            match msg {
                :stop => {
                    let _ = terminate_typed::<T>(state, :normal);
                    :ok
                },
                (:stop, reason) => {
                    let _ = terminate_typed::<T>(state, reason);
                    :ok
                },
                _ => {
                    let result = GenServer::handle_cast::<T>(msg, state);
                    match result {
                        (:noreply, new_state) => server_loop_typed::<T>(new_state),
                        (:stop, reason, new_state) => {
                            let _ = terminate_typed::<T>(new_state, reason);
                            :ok
                        },
                        _ => server_loop_typed::<T>(state)
                    }
                }
            }
        },
        // Any other message goes to handle_info
        other => {
            let result = GenServer::handle_info::<T>(other, state);
            match result {
                (:noreply, new_state) => server_loop_typed::<T>(new_state),
                (:stop, reason, new_state) => {
                    let _ = terminate_typed::<T>(new_state, reason);
                    :ok
                },
                _ => server_loop_typed::<T>(state)
            }
        }
    }
}

/// The main server loop.
fn server_loop(module: Atom, state: Any) -> Atom {
    receive {
        // Call protocol: {:gen_call, {pid, ref}, request}
        (:gen_call, (from_pid, from_ref), msg) => {
            let from = From { pid: from_pid, ref: from_ref };
            let result = erl::apply(module, :handle_call, [msg, from, state]);
            match result {
                (:reply, response, new_state) => {
                    reply(from, response);
                    server_loop(module, new_state)
                },
                (:noreply, new_state) => {
                    server_loop(module, new_state)
                },
                (:stop, reason, response, new_state) => {
                    reply(from, response);
                    let _ = call_terminate(module, reason, new_state);
                    :ok
                },
                _ => server_loop(module, state)
            }
        },
        // Cast protocol: {:gen_cast, request}
        (:gen_cast, msg) => {
            // Handle special :stop message
            match msg {
                :stop => {
                    let _ = call_terminate(module, :normal, state);
                    :ok
                },
                (:stop, reason) => {
                    let _ = call_terminate(module, reason, state);
                    :ok
                },
                _ => {
                    let result = erl::apply(module, :handle_cast, [msg, state]);
                    match result {
                        (:noreply, new_state) => server_loop(module, new_state),
                        (:stop, reason, new_state) => {
                            let _ = call_terminate(module, reason, new_state);
                            :ok
                        },
                        _ => server_loop(module, state)
                    }
                }
            }
        },
        // Any other message goes to handle_info
        other => {
            let result = call_handle_info(module, other, state);
            match result {
                (:noreply, new_state) => server_loop(module, new_state),
                (:stop, reason, new_state) => {
                    let _ = call_terminate(module, reason, new_state);
                    :ok
                },
                _ => server_loop(module, state)
            }
        }
    }
}

/// Call handle_info if exported, otherwise use default (ignore message).
fn call_handle_info(module: Atom, msg: Any, state: Any) -> (Atom, Any) {
    if erl::function_exported(module, :handle_info, 2) {
        erl::apply(module, :handle_info, [msg, state])
    } else {
        (:noreply, state)  // Default: ignore message
    }
}

/// Call terminate if exported, otherwise use default (do nothing).
fn call_terminate(module: Atom, reason: Atom, state: Any) -> Atom {
    if erl::function_exported(module, :terminate, 2) {
        erl::apply(module, :terminate, [reason, state])
    } else {
        :ok  // Default: do nothing
    }
}

/// Call terminate for typed GenServer. Takes state first so trait dispatch
/// can use the state's __struct__ tag for method resolution.
fn terminate_typed<T: GenServer>(state: Any, reason: Atom) {
    let _ = GenServer::terminate::<T>(reason, state);
}
