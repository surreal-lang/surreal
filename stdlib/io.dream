// Dream Standard Library - I/O Module
//
// Provides console input/output functions.

use erlang::std::io as erl_io;
use display::DisplayOpts;

/// Print a string followed by a newline.
pub fn println(s: String) {
    let _ = erl_io::format("~s~n", [s]);
}

/// Print with format string (like Erlang's io:format).
pub fn format(fmt: String, args: Any) {
    let _ = erl_io::format(fmt, args);
}

/// Print a string without a newline.
pub fn print(s: String) {
    let _ = erl_io::format("~s", [s]);
}

/// Print an integer followed by a newline.
pub fn println_int(n: int) {
    let _ = erl_io::format("~p~n", [n]);
}

/// Display a term and print it, returning the term for chaining.
/// This is useful for debugging pipelines.
///
/// Example:
///   let result = data |> transform() |> io::dbg() |> process();
pub fn dbg<T>(term: T) -> T {
    println(display::display_any(term));
    term
}

/// Display a term with options and print it, returning the term for chaining.
///
/// Example:
///   data |> io::dbg_opts(display::DisplayOpts::pretty())
///   data |> io::dbg_opts(display::DisplayOpts::new().with_label("debug"))
pub fn dbg_opts(term: Any, opts: DisplayOpts) -> Any {
    println(display::display_any_opts(term, opts));
    term
}

/// Read a line from standard input.
pub fn read_line() -> String {
    erl_io::get_line("")
}

/// Read a line with a prompt.
pub fn read_line_prompt(prompt: String) -> String {
    erl_io::get_line(prompt)
}
