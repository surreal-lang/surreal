// Dream Standard Library - Application Module
//
// Provides OTP Application behavior for managing supervision trees
// and application lifecycle.

use erlang::std::application as erl_app;
use erlang::std::erlang as erl;

/// Start type for application startup.
/// - `:normal` - Standard application start
/// - `:takeover` - Distributed takeover (app started on another node)
/// - `:failover` - Distributed failover (app failed on another node)
pub type StartType = :normal | :takeover | :failover;

/// The Application trait.
/// Implement this to create an OTP application with lifecycle hooks.
///
/// Example:
/// ```
/// use application::Application;
/// use supervisor;
///
/// impl Application {
///     fn start(_start_type: StartType, _args: Any) -> Result<Pid, Any> {
///         let children = [
///             (:worker, :my_worker, [], :permanent, :worker)
///         ];
///         let flags = (:one_for_one, 5, 10);
///         match supervisor::start_link(:my_app_sup, (flags, children)) {
///             (:ok, pid) => Ok(pid),
///             (:error, reason) => Err(reason)
///         }
///     }
/// }
/// ```
pub trait Application {
    /// Called when the application starts.
    ///
    /// `start_type` is typically `:normal`, but can be `:takeover` or `:failover`
    /// in distributed systems.
    /// `args` comes from the application's .app file.
    ///
    /// Returns Ok(supervisor_pid) on success or Err(reason) on failure.
    fn start(start_type: StartType, args: Any) -> Result<Pid, Any>;

    /// Called before the application stops (optional).
    /// The state is the pid returned from start/2.
    /// Return the state to pass to stop/1.
    fn prep_stop(state: Pid) -> Pid {
        state
    }

    /// Called when the application stops (optional).
    /// The state is what was returned from prep_stop/1.
    fn stop(state: Pid) -> Atom {
        :ok
    }
}

// ============== Application Environment API ==============

/// Get an environment value for the current application.
/// Returns None if the key is not set.
pub fn get_env(key: Atom) -> Option<Any> {
    match erl_app::get_application() {
        Ok(app) => get_env_for(app, key),
        Err(_) => None,
        _ => None,
    }
}

/// Get an environment value for a specific application.
pub fn get_env_for(app: Atom, key: Atom) -> Option<Any> {
    match erl_app::get_env(app, key) {
        Ok(value) => Some(value),
        Err(_) => None,
        _ => None,
    }
}

/// Get an environment value with a default.
pub fn get_env_default(key: Atom, default: Any) -> Any {
    match get_env(key) {
        Some(value) => value,
        None => default,
        _ => default,
    }
}

/// Get an environment value for a specific application with a default.
pub fn get_env_for_default(app: Atom, key: Atom, default: Any) -> Any {
    match get_env_for(app, key) {
        Some(value) => value,
        None => default,
        _ => default,
    }
}

/// Fetch environment value, crashes if not set.
pub fn fetch_env(key: Atom) -> Any {
    match get_env(key) {
        Some(value) => value,
        None => erl::error((:missing_env, key)),
        _ => erl::error((:missing_env, key)),
    }
}

/// Fetch environment value for specific app, crashes if not set.
pub fn fetch_env_for(app: Atom, key: Atom) -> Any {
    match get_env_for(app, key) {
        Some(value) => value,
        None => erl::error((:missing_env, app, key)),
        _ => erl::error((:missing_env, app, key)),
    }
}

/// Set an environment value for the current application.
pub fn put_env(key: Atom, value: Any) -> Atom {
    match erl_app::get_application() {
        Ok(app) => put_env_for(app, key, value),
        Err(_) => :error,
        _ => :error,
    }
}

/// Set an environment value for a specific application.
pub fn put_env_for(app: Atom, key: Atom, value: Any) -> Atom {
    erl_app::set_env(app, key, value)
}

/// Get all environment for the current application.
pub fn get_all_env() -> [(Atom, Any)] {
    match erl_app::get_application() {
        Ok(app) => get_all_env_for(app),
        Err(_) => [],
        _ => [],
    }
}

/// Get all environment for a specific application.
pub fn get_all_env_for(app: Atom) -> [(Atom, Any)] {
    erl_app::get_all_env(app)
}

// ============== Application Control API ==============

/// Start an application.
pub fn start(app: Atom) -> Result<Atom, Any> {
    erl_app::start(app)
}

/// Stop an application.
pub fn stop(app: Atom) -> Result<Atom, Any> {
    erl_app::stop(app)
}

/// Ensure an application is started.
/// Also starts any dependencies.
pub fn ensure_started(app: Atom) -> Result<[Atom], Any> {
    erl_app::ensure_all_started(app)
}

/// Ensure an application is started (simple version).
/// Returns :ok on success.
pub fn ensure_started_simple(app: Atom) -> Atom {
    match ensure_started(app) {
        Ok(_) => :ok,
        Err(reason) => erl::error(reason),
        _ => erl::error(:unknown),
    }
}

/// Get information about a running application.
pub fn info(app: Atom) -> Result<[(Atom, Any)], Atom> {
    erl_app::get_all_key(app)
}

/// Get which applications are currently running.
pub fn which_applications() -> [(Atom, Any, Any)] {
    erl_app::which_applications()
}

/// Get the application that owns the calling process.
pub fn get_application() -> Option<Atom> {
    match erl_app::get_application() {
        Ok(app) => Some(app),
        Err(_) => None,
        _ => None,
    }
}
