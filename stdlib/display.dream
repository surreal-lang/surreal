// Dream Standard Library - Display Module
//
// Provides the Display trait for converting values to readable string representations.
// Similar to Rust's Display trait.

// Binary-safe string concatenation
fn concat(a: any, b: any) -> binary {
    :erlang::iolist_to_binary([a, b])
}

fn concat3(a: any, b: any, c: any) -> binary {
    :erlang::iolist_to_binary([a, b, c])
}


/// Options for controlling display output.
pub struct DisplayOpts {
    /// Pretty print with newlines and indentation
    pretty: bool,
    /// Maximum number of items to show in collections (0 = unlimited)
    limit: int,
    /// Line width for pretty printing
    width: int,
    /// Optional label to prefix the output
    label: string,
}

impl DisplayOpts {
    /// Create default display options.
    pub fn new() -> DisplayOpts {
        DisplayOpts {
            pretty: false,
            limit: 50,
            width: 80,
            label: "",
        }
    }

    /// Create pretty-printing options.
    pub fn pretty() -> DisplayOpts {
        DisplayOpts {
            pretty: true,
            limit: 50,
            width: 80,
            label: "",
        }
    }

    /// Set a label for the output.
    pub fn with_label(self, label: string) -> DisplayOpts {
        DisplayOpts { label: label, ..self }
    }

    /// Set the item limit.
    pub fn with_limit(self, limit: int) -> DisplayOpts {
        DisplayOpts { limit: limit, ..self }
    }

    /// Set the line width.
    pub fn with_width(self, width: int) -> DisplayOpts {
        DisplayOpts { width: width, ..self }
    }

    /// Enable pretty printing.
    pub fn with_pretty(self, pretty: bool) -> DisplayOpts {
        DisplayOpts { pretty: pretty, ..self }
    }
}

/// Trait for types that can be displayed (converted to readable strings).
///
/// Implement this trait to customize how your types are displayed.
/// The default implementation uses Erlang's term formatting.
pub trait Display {
    /// Convert to a binary representation with default options.
    fn display(self) -> binary {
        self.display(DisplayOpts::new())
    }

    /// Convert to a binary representation with custom options.
    fn display(self, opts: DisplayOpts) -> binary;
}

/// Type-safe display with compile-time trait bound checking.
/// Use this when you know the type implements Display.
/// This function is monomorphized at compile time for each concrete type.
pub fn display<T: Display>(value: T) -> binary {
    Display::display(value)
}

/// Type-safe display with options and compile-time trait bound checking.
pub fn display_opts<T: Display>(value: T, opts: DisplayOpts) -> binary {
    Display::display(value, opts)
}

// Helper function to format any term using Erlang's io_lib
// This is used as the fallback for types without custom Display impls
pub fn format_term(term: any) -> binary {
    :erlang::iolist_to_binary(:io_lib::format("~p", [term]))
}

// Format with a limit on collection items
pub fn format_term_limit(term: any, limit: int) -> binary {
    if limit == 0 {
        :erlang::iolist_to_binary(:io_lib::format("~p", [term]))
    } else {
        :erlang::iolist_to_binary(:io_lib::format("~P", [term, limit]))
    }
}

/// Display any term, dispatching to Display trait if implemented.
/// Falls back to Erlang's term formatting for primitives and unknown types.
pub fn display_any(term: any) -> binary {
    do_display_any(term, DisplayOpts::new())
}

pub fn display_any_opts(term: any, opts: DisplayOpts) -> binary {
    do_display_any(term, opts)
}

fn do_display_any(term: any, opts: DisplayOpts) -> binary {
    // Check if this is a struct (map with __struct__ key)
    let formatted = if :erlang::is_map(term) {
        match :maps::get(:__struct__, term, :not_a_struct) {
            :not_a_struct => format_value(term, opts),
            struct_tag => format_struct(term, struct_tag, opts)
        }
    } else {
        format_value(term, opts)
    };

    // Add label if present
    if opts.label == "" {
        formatted
    } else {
        concat(concat(opts.label, ": "), formatted)
    }
}

/// Format a struct in Rust-like syntax: TypeName { field: value, ... }
fn format_struct(term: any, struct_tag: atom, opts: DisplayOpts) -> binary {
    // Extract type name from tag (e.g., 'module::TypeName' -> 'TypeName')
    let tag_str = :erlang::atom_to_list(struct_tag);
    let type_name = extract_type_name(tag_str);

    // Get all fields except __struct__
    let all_fields = :maps::to_list(term);
    let fields = :lists::filter(|entry| {
        let key = :erlang::element(1, entry);
        key != :__struct__
    }, all_fields);

    // Format fields
    let field_strs = :lists::map(|entry| {
        let key = :erlang::element(1, entry);
        let value = :erlang::element(2, entry);
        let key_str = :erlang::atom_to_list(key);
        let value_str = format_value(value, opts);
        concat(concat(:erlang::list_to_binary(key_str), ": "), value_str)
    }, fields);

    // Join with ", "
    let fields_str = join_strings(field_strs, ", ");

    // Build "TypeName { fields }"
    concat(concat(concat(type_name, " { "), fields_str), " }")
}

/// Extract the type name from a fully qualified name like "module::TypeName"
fn extract_type_name(tag_str: any) -> binary {
    // Find the last "::" and take everything after it
    let parts = :string::split(tag_str, "::", :all);
    let last = :lists::last(parts);
    :erlang::list_to_binary(last)
}

/// Format a non-struct value
fn format_value(term: any, opts: DisplayOpts) -> binary {
    if :erlang::is_binary(term) {
        // Binary string - show with quotes
        concat3("\"", term, "\"")
    } else if :erlang::is_atom(term) {
        format_atom(term)
    } else if :erlang::is_list(term) {
        // Check if it's a printable string (charlist)
        if :io_lib::printable_list(term) {
            // It's a string - show with quotes
            concat3("\"", :erlang::list_to_binary(term), "\"")
        } else {
            format_list(term, opts)
        }
    } else if :erlang::is_tuple(term) {
        format_tuple(term, opts)
    } else if :erlang::is_map(term) {
        // Check for nested struct
        match :maps::get(:__struct__, term, :not_a_struct) {
            :not_a_struct => format_map(term, opts),
            struct_tag => format_struct(term, struct_tag, opts)
        }
    } else {
        // Numbers, pids, etc - use default formatting
        :erlang::iolist_to_binary(:io_lib::format("~p", [term]))
    }
}

/// Format an atom with special handling for Result/Option variants
fn format_atom(term: any) -> binary {
    if term == :true {
        :erlang::iolist_to_binary("true")
    } else if term == :false {
        :erlang::iolist_to_binary("false")
    } else if term == :ok {
        // Result<(), E> success case
        :erlang::iolist_to_binary("Ok(())")
    } else if term == :none {
        // Option::None
        :erlang::iolist_to_binary("None")
    } else {
        // Regular atom - show with colon prefix
        let atom_str = :erlang::atom_to_list(term);
        concat(":", :erlang::list_to_binary(atom_str))
    }
}

/// Format a list
fn format_list(term: any, opts: DisplayOpts) -> binary {
    let items = :lists::map(|item| { format_value(item, opts) }, term);
    let items_str = join_strings(items, ", ");
    concat(concat("[", items_str), "]")
}

/// Format a tuple with special handling for Result/Option
fn format_tuple(term: any, opts: DisplayOpts) -> binary {
    let size = :erlang::tuple_size(term);

    // Check for Result/Option patterns (2-element tuples with specific tags)
    if size == 2 {
        let tag = :erlang::element(1, term);
        let value = :erlang::element(2, term);

        if tag == :ok {
            // Result::Ok(value)
            concat(concat("Ok(", format_value(value, opts)), ")")
        } else if tag == :error {
            // Result::Err(value)
            concat(concat("Err(", format_value(value, opts)), ")")
        } else if tag == :some {
            // Option::Some(value)
            concat(concat("Some(", format_value(value, opts)), ")")
        } else {
            // Regular tuple
            format_regular_tuple(term, size, opts)
        }
    } else {
        // Regular tuple
        format_regular_tuple(term, size, opts)
    }
}

/// Format a regular tuple (not Result/Option)
fn format_regular_tuple(term: any, size: int, opts: DisplayOpts) -> binary {
    let items = tuple_to_list(term, 1, size, opts);
    let items_str = join_strings(items, ", ");
    concat(concat("(", items_str), ")")
}

/// Convert tuple elements to formatted strings
fn tuple_to_list(tuple: any, idx: int, size: int, opts: DisplayOpts) -> [binary] {
    if idx > size {
        []
    } else {
        let elem = :erlang::element(idx, tuple);
        let formatted = format_value(elem, opts);
        let rest = tuple_to_list(tuple, idx + 1, size, opts);
        :lists::append([formatted], rest)
    }
}

/// Format a plain map (not a struct)
fn format_map(term: any, opts: DisplayOpts) -> binary {
    let entries = :maps::to_list(term);
    let entry_strs = :lists::map(|entry| {
        let key = :erlang::element(1, entry);
        let value = :erlang::element(2, entry);
        let key_str = format_value(key, opts);
        let value_str = format_value(value, opts);
        concat(concat(key_str, " => "), value_str)
    }, entries);
    let entries_str = join_strings(entry_strs, ", ");
    concat(concat("{ ", entries_str), " }")
}

/// Join a list of strings with a separator
fn join_strings(strings: [binary], sep: any) -> binary {
    let iolist = :lists::join(sep, strings);
    :erlang::iolist_to_binary(iolist)
}
