// Dream Standard Library - Process Module
//
// Provides process management and communication functions.

use erlang::std::erlang as erl;
use erlang::std::timer as erl_timer;

/// Get the current process's PID.
/// Note: You can also use the built-in `self()` expression directly.
pub fn current() -> Pid {
    self()
}

/// Sleep for the given number of milliseconds.
pub fn sleep(ms: int) {
    let _ = erl_timer::sleep(ms);
}

/// Check if a process is alive.
pub fn is_alive(p: Pid) -> bool {
    erl::is_process_alive(p)
}

/// Send a message to a process.
pub fn send<T>(p: Pid, msg: T) {
    let _ = erl::send(p, msg);
}

/// Register a process with a name.
/// Returns true on success.
pub fn register(name: Atom, p: Pid) -> bool {
    erl::register(name, p)
}

/// Unregister a process name.
/// Returns true on success.
pub fn unregister(name: Atom) -> bool {
    erl::unregister(name)
}

/// Look up a registered process by name.
pub fn whereis(name: Atom) -> Pid {
    erl::whereis(name)
}

/// Get a list of all registered process names.
pub fn registered() -> [Atom] {
    erl::registered()
}

/// Link to another process.
/// Returns true on success.
pub fn link(p: Pid) -> bool {
    erl::link(p)
}

/// Unlink from another process.
/// Returns true on success.
pub fn unlink(p: Pid) -> bool {
    erl::unlink(p)
}

/// Exit the current process with a reason.
pub fn exit(reason: Atom) -> Atom {
    erl::exit(reason)
}

/// Exit another process with a reason.
/// Returns true on success.
pub fn exit_pid(p: Pid, reason: Atom) -> bool {
    erl::exit(p, reason)
}

/// Get a list of all processes.
pub fn list() -> [Pid] {
    erl::processes()
}

/// Set the process flag for trapping exits.
pub fn trap_exit(flag: bool) -> bool {
    erl::process_flag(:trap_exit, flag)
}
