// Surreal Standard Library - Display Module
//
// Provides the Display trait for converting values to readable string representations.
// Similar to Rust's Display trait.

use erlang::std::erlang as erl;
use erlang::std::io_lib as erl_io_lib;
use erlang::std::maps as erl_maps;
use erlang::std::lists as erl_lists;
use erlang::std::string as erl_string;

// Binary-safe string concatenation
fn concat(a: Any, b: Any) -> String {
    erl::iolist_to_binary([a, b])
}

fn concat3(a: Any, b: Any, c: Any) -> String {
    erl::iolist_to_binary([a, b, c])
}


/// Options for controlling display output.
pub struct DisplayOpts {
    /// Pretty print with newlines and indentation
    pretty: bool,
    /// Maximum number of items to show in collections (0 = unlimited)
    limit: int,
    /// Line width for pretty printing
    width: int,
    /// Optional label to prefix the output
    label: String,
}

impl DisplayOpts {
    /// Create default display options.
    pub fn new() -> DisplayOpts {
        DisplayOpts {
            pretty: false,
            limit: 50,
            width: 80,
            label: "",
        }
    }

    /// Create pretty-printing options.
    pub fn pretty() -> DisplayOpts {
        DisplayOpts {
            pretty: true,
            limit: 50,
            width: 80,
            label: "",
        }
    }

    /// Set a label for the output.
    pub fn with_label(self, label: String) -> DisplayOpts {
        DisplayOpts { label: label, ..self }
    }

    /// Set the item limit.
    pub fn with_limit(self, limit: int) -> DisplayOpts {
        DisplayOpts { limit: limit, ..self }
    }

    /// Set the line width.
    pub fn with_width(self, width: int) -> DisplayOpts {
        DisplayOpts { width: width, ..self }
    }

    /// Enable pretty printing.
    pub fn with_pretty(self, pretty: bool) -> DisplayOpts {
        DisplayOpts { pretty: pretty, ..self }
    }
}

/// Trait for types that can be displayed (converted to readable strings).
///
/// Implement this trait to customize how your types are displayed.
/// The default implementation uses Erlang's term formatting.
pub trait Display {
    /// Convert to a binary representation with default options.
    fn display(self) -> String {
        self.display(DisplayOpts::new())
    }

    /// Convert to a binary representation with custom options.
    fn display(self, opts: DisplayOpts) -> String;
}

/// Type-safe display with compile-time trait bound checking.
/// Use this when you know the type implements Display.
/// This function is monomorphized at compile time for each concrete type.
pub fn display<T: Display>(value: T) -> String {
    Display::display(value)
}

/// Type-safe display with options and compile-time trait bound checking.
pub fn display_opts<T: Display>(value: T, opts: DisplayOpts) -> String {
    Display::display(value, opts)
}

// Helper function to format any term using Erlang's io_lib
// This is used as the fallback for types without custom Display impls
pub fn format_term(term: Any) -> String {
    erl::iolist_to_binary(erl_io_lib::format("~p", [term]))
}

// Format with a limit on collection items
pub fn format_term_limit(term: Any, limit: int) -> String {
    if limit == 0 {
        erl::iolist_to_binary(erl_io_lib::format("~p", [term]))
    } else {
        erl::iolist_to_binary(erl_io_lib::format("~P", [term, limit]))
    }
}

/// Display any term, dispatching to Display trait if implemented.
/// Falls back to Erlang's term formatting for primitives and unknown types.
pub fn display_any(term: Any) -> String {
    do_display_any(term, DisplayOpts::new())
}

/// Convert any term to a string for interpolation.
/// Unlike display_any, this doesn't add quotes around strings.
/// Use this for string interpolation: "Hello {name}!"
pub fn to_string(term: Any) -> String {
    if erl::is_binary(term) {
        // Return string directly without quotes
        term
    } else if erl::is_list(term) {
        // Check if it's a printable string (charlist)
        if erl_io_lib::printable_list(term) {
            erl::list_to_binary(term)
        } else {
            display_any(term)
        }
    } else {
        // For other types, use standard display
        display_any(term)
    }
}

pub fn display_any_opts(term: Any, opts: DisplayOpts) -> String {
    do_display_any(term, opts)
}

fn do_display_any(term: Any, opts: DisplayOpts) -> String {
    // Check if this is a struct (map with __struct__ key)
    let formatted = if erl::is_map(term) {
        match erl_maps::get(:__struct__, term, :not_a_struct) {
            :not_a_struct => format_value(term, opts),
            struct_tag => format_struct(term, struct_tag, opts)
        }
    } else {
        format_value(term, opts)
    };

    // Add label if present
    if opts.label == "" {
        formatted
    } else {
        concat(concat(opts.label, ": "), formatted)
    }
}

/// Format a struct in Rust-like syntax: TypeName { field: value, ... }
fn format_struct(term: Any, struct_tag: Atom, opts: DisplayOpts) -> String {
    // Extract type name from tag (e.g., 'module::TypeName' -> 'TypeName')
    let tag_str = erl::atom_to_list(struct_tag);
    let type_name = extract_type_name(tag_str);

    // Get all fields except __struct__
    let all_fields = erl_maps::to_list(term);
    let fields = erl_lists::filter(|entry| {
        let key = erl::element(1, entry);
        key != :__struct__
    }, all_fields);

    // Format fields
    let field_strs = erl_lists::map(|entry| {
        let key = erl::element(1, entry);
        let value = erl::element(2, entry);
        let key_str = erl::atom_to_list(key);
        let value_str = format_value(value, opts);
        concat(concat(erl::list_to_binary(key_str), ": "), value_str)
    }, fields);

    // Join with ", "
    let fields_str = join_strings(field_strs, ", ");

    // Build "TypeName { fields }"
    concat(concat(concat(type_name, " {{ "), fields_str), " }}")
}

/// Extract the type name from a fully qualified name like "module::TypeName"
fn extract_type_name(tag_str: Any) -> String {
    // Find the last "::" and take everything after it
    let parts = erl_string::split(tag_str, "::", :all);
    let last = erl_lists::last(parts);
    erl::list_to_binary(last)
}

/// Format a non-struct value
fn format_value(term: Any, opts: DisplayOpts) -> String {
    if erl::is_binary(term) {
        // Binary string - show with quotes
        concat3("\"", term, "\"")
    } else if erl::is_atom(term) {
        format_atom(term)
    } else if erl::is_list(term) {
        // Check if it's a printable string (charlist)
        if erl_io_lib::printable_list(term) {
            // It's a string - show with quotes
            concat3("\"", erl::list_to_binary(term), "\"")
        } else {
            format_list(term, opts)
        }
    } else if erl::is_tuple(term) {
        format_tuple(term, opts)
    } else if erl::is_map(term) {
        // Check for nested struct
        match erl_maps::get(:__struct__, term, :not_a_struct) {
            :not_a_struct => format_map(term, opts),
            struct_tag => format_struct(term, struct_tag, opts)
        }
    } else {
        // Numbers, pids, etc - use default formatting
        erl::iolist_to_binary(erl_io_lib::format("~p", [term]))
    }
}

/// Format an atom with special handling for Result/Option variants
fn format_atom(term: Any) -> String {
    if term == :true {
        erl::iolist_to_binary("true")
    } else if term == :false {
        erl::iolist_to_binary("false")
    } else if term == :ok {
        // Result<(), E> success case
        erl::iolist_to_binary("Ok(())")
    } else if term == :none {
        // Option::None
        erl::iolist_to_binary("None")
    } else {
        // Regular atom - show with colon prefix
        let atom_str = erl::atom_to_list(term);
        concat(":", erl::list_to_binary(atom_str))
    }
}

/// Format a list
fn format_list(term: Any, opts: DisplayOpts) -> String {
    let items = erl_lists::map(|item| { format_value(item, opts) }, term);
    let items_str = join_strings(items, ", ");
    concat(concat("[", items_str), "]")
}

/// Format a tuple with special handling for Result/Option
fn format_tuple(term: Any, opts: DisplayOpts) -> String {
    let size = erl::tuple_size(term);

    // Check for Result/Option patterns (2-element tuples with specific tags)
    if size == 2 {
        let tag = erl::element(1, term);
        let value = erl::element(2, term);

        if tag == :ok {
            // Result::Ok(value)
            concat(concat("Ok(", format_value(value, opts)), ")")
        } else if tag == :error {
            // Result::Err(value)
            concat(concat("Err(", format_value(value, opts)), ")")
        } else if tag == :some {
            // Option::Some(value)
            concat(concat("Some(", format_value(value, opts)), ")")
        } else {
            // Regular tuple
            format_regular_tuple(term, size, opts)
        }
    } else {
        // Regular tuple
        format_regular_tuple(term, size, opts)
    }
}

/// Format a regular tuple (not Result/Option)
fn format_regular_tuple(term: Any, size: int, opts: DisplayOpts) -> String {
    let items = tuple_to_list(term, 1, size, opts);
    let items_str = join_strings(items, ", ");
    concat(concat("(", items_str), ")")
}

/// Convert tuple elements to formatted strings
fn tuple_to_list(tuple: Any, idx: int, size: int, opts: DisplayOpts) -> [String] {
    if idx > size {
        []
    } else {
        let elem = erl::element(idx, tuple);
        let formatted = format_value(elem, opts);
        let rest = tuple_to_list(tuple, idx + 1, size, opts);
        erl_lists::append([formatted], rest)
    }
}

/// Format a plain map (not a struct)
fn format_map(term: Any, opts: DisplayOpts) -> String {
    let entries = erl_maps::to_list(term);
    let entry_strs = erl_lists::map(|entry| {
        let key = erl::element(1, entry);
        let value = erl::element(2, entry);
        let key_str = format_value(key, opts);
        let value_str = format_value(value, opts);
        concat(concat(key_str, " => "), value_str)
    }, entries);
    let entries_str = join_strings(entry_strs, ", ");
    concat(concat("{{ ", entries_str), " }}")
}

/// Join a list of strings with a separator
fn join_strings(strings: [String], sep: Any) -> String {
    let iolist = erl_lists::join(strings, sep);
    erl::iolist_to_binary(iolist)
}
