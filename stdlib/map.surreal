// Surreal Standard Library - Map Module
//
// Provides a key-value map backed by Erlang maps with Option/Result-based access.
// Uses Option and Result from the prelude.

use erlang::std::maps as erl_maps;
use erlang::std::lists as erl_lists;
use erlang::std::erlang as erl;

/// Error type for map operations
pub enum KeyError {
    NotFound,
}

/// A key-value map backed by Erlang maps.
/// Note: Due to parser limitations, Map is not generic at the struct level,
/// but functions use generic type parameters.
pub struct Map {
    data: map,
}

impl Map {
    /// Create an empty map
    pub fn new<K, V>() -> Self {
        Map { data: erl_maps::new() }
    }

    /// Create a map from a list of key-value pairs
    pub fn from_list<K, V>(pairs: [(K, V)]) -> Self {
        Map { data: erl_maps::from_list(pairs) }
    }

    /// Get a value by key, returns None if not found
    pub fn get<K, V>(self, key: K) -> Option<V> {
        if erl_maps::is_key(key, self.data) {
            Some(erl_maps::get(key, self.data))
        } else {
            None
        }
    }

    /// Get a value by key, returns default if not found
    pub fn get_or<K, V>(self, key: K, default: V) -> V {
        erl_maps::get(key, self.data, default)
    }

    /// Fetch a value by key, returns Result
    pub fn fetch<K, V>(self, key: K) -> Result<V, KeyError> {
        if erl_maps::is_key(key, self.data) {
            Ok(erl_maps::get(key, self.data))
        } else {
            Err(KeyError::NotFound)
        }
    }

    /// Check if key exists
    pub fn has_key<K>(self, key: K) -> bool {
        erl_maps::is_key(key, self.data)
    }

    /// Insert or update a key-value pair
    pub fn put<K, V>(self, key: K, value: V) -> Self {
        Map { data: erl_maps::put(key, value, self.data) }
    }

    /// Remove a key (returns same map if key doesn't exist)
    pub fn delete<K>(self, key: K) -> Self {
        if erl_maps::is_key(key, self.data) {
            Map { data: erl_maps::remove(key, self.data) }
        } else {
            self
        }
    }

    /// Merge two maps (values from other win on conflict)
    pub fn merge(self, other: Self) -> Self {
        Map { data: erl_maps::merge(self.data, other.data) }
    }

    /// Get all keys as a list
    pub fn keys<K>(self) -> [K] {
        erl_maps::keys(self.data)
    }

    /// Get all values as a list
    pub fn values<V>(self) -> [V] {
        erl_maps::values(self.data)
    }

    /// Convert to list of key-value tuples
    pub fn to_list<K, V>(self) -> [(K, V)] {
        erl_maps::to_list(self.data)
    }

    /// Get number of entries
    pub fn size(self) -> int {
        erl_maps::size(self.data)
    }

    /// Check if map is empty
    pub fn is_empty(self) -> bool {
        erl_maps::size(self.data) == 0
    }
}

/// Enumerable operations for Map - each entry is a (key, value) tuple.
impl Map {
    pub fn map<K, V, U>(self, f: fn((K, V)) -> U) -> [U] {
        erl_lists::map(f, erl_maps::to_list(self.data))
    }

    pub fn filter<K, V>(self, pred: fn((K, V)) -> bool) -> [(K, V)] {
        erl_lists::filter(pred, erl_maps::to_list(self.data))
    }

    pub fn reduce<K, V, Acc>(self, init: Acc, f: fn((K, V), Acc) -> Acc) -> Acc {
        erl_lists::foldl(f, init, erl_maps::to_list(self.data))
    }

    pub fn any<K, V>(self, pred: fn((K, V)) -> bool) -> bool {
        erl_lists::any(pred, erl_maps::to_list(self.data))
    }

    pub fn all<K, V>(self, pred: fn((K, V)) -> bool) -> bool {
        erl_lists::all(pred, erl_maps::to_list(self.data))
    }

    pub fn count<K, V>(self, pred: fn((K, V)) -> bool) -> int {
        erl::length(erl_lists::filter(pred, erl_maps::to_list(self.data)))
    }

    pub fn take<K, V>(self, n: int) -> [(K, V)] {
        erl_lists::sublist(erl_maps::to_list(self.data), n)
    }

    pub fn drop<K, V>(self, n: int) -> [(K, V)] {
        erl_lists::nthtail(n, erl_maps::to_list(self.data))
    }

    pub fn reverse<K, V>(self) -> [(K, V)] {
        erl_lists::reverse(erl_maps::to_list(self.data))
    }
}
