// Dream Standard Library - Result Module
//
// Provides the Result<T, E> type for representing success or failure.

/// Result type - represents either success (Ok) or failure (Err).
pub enum Result<T, E> {
    Ok(T),
    Err(E),
}

/// Check if the result is Ok.
pub fn is_ok<T, E>(res: Result<T, E>) -> bool {
    match res {
        Ok(_) => true,
        Err(_) => false,
    }
}

/// Check if the result is Err.
pub fn is_err<T, E>(res: Result<T, E>) -> bool {
    match res {
        Ok(_) => false,
        Err(_) => true,
    }
}

/// Unwrap the result, returning the Ok value.
/// Panics if the result is Err.
pub fn unwrap<T, E>(res: Result<T, E>) -> T {
    match res {
        Ok(x) => x,
        Err(e) => :erlang::error((:unwrap_err, e)),
    }
}

/// Unwrap the result, returning a default value if Err.
pub fn unwrap_or<T, E>(res: Result<T, E>, default: T) -> T {
    match res {
        Ok(x) => x,
        Err(_) => default,
    }
}

/// Unwrap the result, calling a function to produce a default if Err.
pub fn unwrap_or_else<T, E>(res: Result<T, E>, f: Fn) -> T {
    match res {
        Ok(x) => x,
        Err(e) => f(e),
    }
}

/// Unwrap the error value.
/// Panics if the result is Ok.
pub fn unwrap_err<T, E>(res: Result<T, E>) -> E {
    match res {
        Ok(x) => :erlang::error((:unwrap_ok, x)),
        Err(e) => e,
    }
}

/// Map a function over the Ok value.
pub fn map<T, U, E>(res: Result<T, E>, f: Fn) -> Result<U, E> {
    match res {
        Ok(x) => Ok(f(x)),
        Err(e) => Err(e),
    }
}

/// Map a function over the Err value.
pub fn map_err<T, E, F>(res: Result<T, E>, f: Fn) -> Result<T, F> {
    match res {
        Ok(x) => Ok(x),
        Err(e) => Err(f(e)),
    }
}

/// Map a function over the Ok value, returning a default if Err.
pub fn map_or<T, U, E>(res: Result<T, E>, default: U, f: Fn) -> U {
    match res {
        Ok(x) => f(x),
        Err(_) => default,
    }
}

/// Apply a function that returns a Result to the Ok value.
pub fn and_then<T, U, E>(res: Result<T, E>, f: Fn) -> Result<U, E> {
    match res {
        Ok(x) => f(x),
        Err(e) => Err(e),
    }
}

/// Return the result if Ok, otherwise return the other result.
pub fn or<T, E, F>(res: Result<T, E>, other: Result<T, F>) -> Result<T, F> {
    match res {
        Ok(x) => Ok(x),
        Err(_) => other,
    }
}

/// Return the result if Ok, otherwise call the function.
pub fn or_else<T, E, F>(res: Result<T, E>, f: Fn) -> Result<T, F> {
    match res {
        Ok(x) => Ok(x),
        Err(e) => f(e),
    }
}

/// Convert a Result to a list (empty for Err, single-element for Ok).
pub fn to_list<T, E>(res: Result<T, E>) -> [T] {
    match res {
        Ok(x) => [x],
        Err(_) => [],
    }
}
