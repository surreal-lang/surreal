// Surreal Standard Library - Iterator Module
//
// Rust-style iterators with lazy evaluation.
//
// The Iterator trait defines a single required method: next()
// next() returns Option<(Item, Self)> - the value and the new iterator state.
//
// Example:
//   Iterator::range(1, 10)
//   |> Iterator::filter(|x| { x % 2 == 0 })
//   |> Iterator::map(|x| { x * x })
//   |> Iterator::collect()
//   // => [4, 16, 36, 64]

use erlang::std::erlang as erl;
use erlang::std::lists as erl_lists;

// ============== Iterator Trait ==============

/// The Iterator trait - implement `next` to create an iterator.
///
/// next(self) should return:
///   - Some((item, new_self)) when there's a value
///   - None when exhausted
pub trait Iterator {
    type Item;

    /// The only required method - returns the next item and new iterator state.
    fn next(self) -> Option<(Self::Item, Self)>;

    /// Get the first element.
    fn first(self) -> Option<Self::Item> {
        match Iterator::next(self) {
            Some((value, _new_self)) => Some(value),
            _ => None
        }
    }

    /// Count the number of elements.
    fn count(self) -> int {
        trait_count_loop(self, 0)
    }

    /// Check if any element matches a predicate.
    fn any(self, pred: Any) -> bool {
        trait_any_loop(self, pred)
    }

    /// Check if all elements match a predicate.
    fn all(self, pred: Any) -> bool {
        trait_all_loop(self, pred)
    }

    /// Find first element matching predicate.
    fn find(self, pred: Any) -> Option<Self::Item> {
        trait_find_loop(self, pred)
    }
}

// Helper functions for default trait methods (using explicit trait dispatch)
fn trait_count_loop<T: Iterator>(iter: T, acc: int) -> int {
    match Iterator::next(iter) {
        Some((_value, new_iter)) => trait_count_loop(new_iter, acc + 1),
        _ => acc
    }
}

fn trait_any_loop<T: Iterator>(iter: T, pred: Any) -> bool {
    match Iterator::next(iter) {
        Some((value, new_iter)) => {
            if erl::apply(pred, [value]) {
                true
            } else {
                trait_any_loop(new_iter, pred)
            }
        },
        _ => false
    }
}

fn trait_all_loop<T: Iterator>(iter: T, pred: Any) -> bool {
    match Iterator::next(iter) {
        Some((value, new_iter)) => {
            if erl::apply(pred, [value]) {
                trait_all_loop(new_iter, pred)
            } else {
                false
            }
        },
        _ => true
    }
}

fn trait_find_loop<T: Iterator>(iter: T, pred: Any) -> Option<Any> {
    match Iterator::next(iter) {
        Some((value, new_iter)) => {
            if erl::apply(pred, [value]) {
                Some(value)
            } else {
                trait_find_loop(new_iter, pred)
            }
        },
        _ => None
    }
}

// ============== Core Iterator Struct ==============

/// A generic iterator that wraps a next function and state.
pub struct Iter {
    next_fn: Any,
    state: Any,
}

impl Iterator for Iter {
    type Item = Any;

    fn next(self) -> Option<(Self::Item, Self)> {
        let result = erl::apply(self.next_fn, [self.state]);
        match result {
            Some((value, new_state)) => {
                Some((value, Iter { next_fn: self.next_fn, state: new_state }))
            },
            _ => None
        }
    }
}

// ============== Iterator Constructors ==============

/// Create an iterator over a range [start, stop).
pub fn range(start: int, stop: int) -> Iter {
    let next_fn = |s| {
        if s < stop {
            Some((s, s + 1))
        } else {
            None
        }
    };
    Iter { next_fn: next_fn, state: start }
}

/// Create an infinite iterator starting from a value.
pub fn from(start: int) -> Iter {
    let next_fn = |s| {
        Some((s, s + 1))
    };
    Iter { next_fn: next_fn, state: start }
}

/// Create an iterator by repeatedly applying a function.
/// Yields: start, f(start), f(f(start)), ...
pub fn iterate(start: Any, f: Any) -> Iter {
    let next_fn = |s| {
        let next_state = erl::apply(f, [s]);
        Some((s, next_state))
    };
    Iter { next_fn: next_fn, state: start }
}

/// Create an iterator that repeats a value n times.
pub fn repeat(value: Any, n: int) -> Iter {
    let next_fn = |count| {
        if count > 0 {
            Some((value, count - 1))
        } else {
            None
        }
    };
    Iter { next_fn: next_fn, state: n }
}

/// Create an iterator that cycles through a list infinitely.
pub fn cycle(items: [Any]) -> Iter {
    let next_fn = |state| {
        let (original, current) = state;
        match current {
            [] => {
                match original {
                    [] => None,
                    [h | t] => Some((h, (original, t))),
                    _ => None
                }
            },
            [h | t] => Some((h, (original, t))),
            _ => None
        }
    };
    Iter { next_fn: next_fn, state: (items, items) }
}

/// Create an iterator from a list.
pub fn from_list(items: [Any]) -> Iter {
    let next_fn = |state| {
        match state {
            [] => None,
            [h | t] => Some((h, t)),
            _ => None
        }
    };
    Iter { next_fn: next_fn, state: items }
}

/// Create an iterator using an unfold function.
/// f(acc) should return Some((value, new_acc)) or None.
pub fn unfold(initial: Any, f: Any) -> Iter {
    Iter { next_fn: f, state: initial }
}

// ============== Iterator Adapters ==============

/// Map a function over an iterator.
pub fn map(iter: Iter, f: Any) -> Iter {
    let next_fn = |state| {
        let (inner_next, inner_state, mapper) = state;
        match erl::apply(inner_next, [inner_state]) {
            Some((value, new_inner)) => {
                let mapped = erl::apply(mapper, [value]);
                Some((mapped, (inner_next, new_inner, mapper)))
            },
            _ => None
        }
    };
    Iter { next_fn: next_fn, state: (iter.next_fn, iter.state, f) }
}

/// Filter an iterator with a predicate.
pub fn filter(iter: Iter, pred: Any) -> Iter {
    let next_fn = |state| {
        filter_step(state)
    };
    Iter { next_fn: next_fn, state: (iter.next_fn, iter.state, pred) }
}

fn filter_step(state: Any) -> Option<(Any, Any)> {
    let (inner_next, inner_state, pred) = state;
    match erl::apply(inner_next, [inner_state]) {
        Some((value, new_inner)) => {
            if erl::apply(pred, [value]) {
                Some((value, (inner_next, new_inner, pred)))
            } else {
                filter_step((inner_next, new_inner, pred))
            }
        },
        _ => None
    }
}

/// Take the first n elements.
pub fn take(iter: Iter, n: int) -> Iter {
    let next_fn = |state| {
        let (inner_next, inner_state, remaining) = state;
        if remaining > 0 {
            match erl::apply(inner_next, [inner_state]) {
                Some((value, new_inner)) => {
                    Some((value, (inner_next, new_inner, remaining - 1)))
                },
                _ => None
            }
        } else {
            None
        }
    };
    Iter { next_fn: next_fn, state: (iter.next_fn, iter.state, n) }
}

/// Skip the first n elements.
pub fn skip(iter: Iter, n: int) -> Iter {
    let skipped = skip_n(iter.next_fn, iter.state, n);
    Iter { next_fn: iter.next_fn, state: skipped }
}

fn skip_n(next_fn: Any, state: Any, n: int) -> Any {
    if n > 0 {
        match erl::apply(next_fn, [state]) {
            Some((_value, new_state)) => skip_n(next_fn, new_state, n - 1),
            _ => state
        }
    } else {
        state
    }
}

/// Take elements while predicate is true.
pub fn take_while(iter: Iter, pred: Any) -> Iter {
    let next_fn = |state| {
        let (inner_next, inner_state, p, done) = state;
        if done {
            None
        } else {
            match erl::apply(inner_next, [inner_state]) {
                Some((value, new_inner)) => {
                    if erl::apply(p, [value]) {
                        Some((value, (inner_next, new_inner, p, false)))
                    } else {
                        None
                    }
                },
                _ => None
            }
        }
    };
    Iter { next_fn: next_fn, state: (iter.next_fn, iter.state, pred, false) }
}

/// Zip two iterators together.
pub fn zip(iter1: Iter, iter2: Iter) -> Iter {
    let next_fn = |state| {
        let (n1, s1, n2, s2) = state;
        match erl::apply(n1, [s1]) {
            Some((v1, new_s1)) => {
                match erl::apply(n2, [s2]) {
                    Some((v2, new_s2)) => {
                        Some(((v1, v2), (n1, new_s1, n2, new_s2)))
                    },
                    _ => None
                }
            },
            _ => None
        }
    };
    Iter { next_fn: next_fn, state: (iter1.next_fn, iter1.state, iter2.next_fn, iter2.state) }
}

/// Add index to each element: (0, a), (1, b), ...
pub fn enumerate(iter: Iter) -> Iter {
    let next_fn = |state| {
        let (inner_next, inner_state, idx) = state;
        match erl::apply(inner_next, [inner_state]) {
            Some((value, new_inner)) => {
                Some(((idx, value), (inner_next, new_inner, idx + 1)))
            },
            _ => None
        }
    };
    Iter { next_fn: next_fn, state: (iter.next_fn, iter.state, 0) }
}

/// Chain two iterators together.
pub fn chain(iter1: Iter, iter2: Iter) -> Iter {
    // State: (phase, n1, s1, n2, s2) where phase is 1 or 2
    let next_fn = |state| {
        chain_step(state)
    };
    Iter { next_fn: next_fn, state: (1, iter1.next_fn, iter1.state, iter2.next_fn, iter2.state) }
}

fn chain_step(state: Any) -> Option<(Any, Any)> {
    let (phase, n1, s1, n2, s2) = state;
    if phase == 1 {
        match erl::apply(n1, [s1]) {
            Some((value, new_s1)) => {
                Some((value, (1, n1, new_s1, n2, s2)))
            },
            _ => {
                // First iterator exhausted, try second
                match erl::apply(n2, [s2]) {
                    Some((value, new_s2)) => {
                        Some((value, (2, n1, s1, n2, new_s2)))
                    },
                    _ => None
                }
            }
        }
    } else {
        match erl::apply(n2, [s2]) {
            Some((value, new_s2)) => {
                Some((value, (2, n1, s1, n2, new_s2)))
            },
            _ => None
        }
    }
}

// ============== Consumers ==============

/// Collect iterator into a list.
/// WARNING: Don't use on infinite iterators!
pub fn collect(iter: Iter) -> [Any] {
    collect_acc(iter.next_fn, iter.state, [])
}

fn collect_acc(next_fn: Any, state: Any, acc: [Any]) -> [Any] {
    match erl::apply(next_fn, [state]) {
        Some((value, new_state)) => {
            collect_acc(next_fn, new_state, erl_lists::append(acc, [value]))
        },
        _ => acc
    }
}

/// Fold/reduce the iterator to a single value.
pub fn fold(iter: Iter, initial: Any, f: Any) -> Any {
    fold_acc(iter.next_fn, iter.state, initial, f)
}

fn fold_acc(next_fn: Any, state: Any, acc: Any, f: Any) -> Any {
    match erl::apply(next_fn, [state]) {
        Some((value, new_state)) => {
            let new_acc = erl::apply(f, [acc, value]);
            fold_acc(next_fn, new_state, new_acc, f)
        },
        _ => acc
    }
}

/// Run iterator for side effects.
pub fn for_each(iter: Iter, f: Any) -> Atom {
    for_each_loop(iter.next_fn, iter.state, f)
}

fn for_each_loop(next_fn: Any, state: Any, f: Any) -> Atom {
    match erl::apply(next_fn, [state]) {
        Some((value, new_state)) => {
            erl::apply(f, [value]);
            for_each_loop(next_fn, new_state, f)
        },
        _ => :ok
    }
}

/// Count elements.
pub fn count(iter: Iter) -> int {
    fold(iter, 0, |acc, _x| { acc + 1 })
}

/// Sum elements.
pub fn sum(iter: Iter) -> int {
    fold(iter, 0, |acc, x| { acc + x })
}

/// Get the first element.
pub fn first(iter: Iter) -> Option<Any> {
    match erl::apply(iter.next_fn, [iter.state]) {
        Some((value, _new_state)) => Some(value),
        _ => None
    }
}

/// Get the last element.
pub fn last(iter: Iter) -> Option<Any> {
    last_acc(iter.next_fn, iter.state, None)
}

fn last_acc(next_fn: Any, state: Any, current: Option<Any>) -> Option<Any> {
    match erl::apply(next_fn, [state]) {
        Some((value, new_state)) => last_acc(next_fn, new_state, Some(value)),
        _ => current
    }
}

/// Find first element matching predicate.
pub fn find(iter: Iter, pred: Any) -> Option<Any> {
    find_loop(iter.next_fn, iter.state, pred)
}

fn find_loop(next_fn: Any, state: Any, pred: Any) -> Option<Any> {
    match erl::apply(next_fn, [state]) {
        Some((value, new_state)) => {
            if erl::apply(pred, [value]) {
                Some(value)
            } else {
                find_loop(next_fn, new_state, pred)
            }
        },
        _ => None
    }
}

/// Check if any element matches predicate.
pub fn any(iter: Iter, pred: Any) -> bool {
    any_loop(iter.next_fn, iter.state, pred)
}

fn any_loop(next_fn: Any, state: Any, pred: Any) -> bool {
    match erl::apply(next_fn, [state]) {
        Some((value, new_state)) => {
            if erl::apply(pred, [value]) {
                true
            } else {
                any_loop(next_fn, new_state, pred)
            }
        },
        _ => false
    }
}

/// Check if all elements match predicate.
pub fn all(iter: Iter, pred: Any) -> bool {
    all_loop(iter.next_fn, iter.state, pred)
}

fn all_loop(next_fn: Any, state: Any, pred: Any) -> bool {
    match erl::apply(next_fn, [state]) {
        Some((value, new_state)) => {
            if erl::apply(pred, [value]) {
                all_loop(next_fn, new_state, pred)
            } else {
                false
            }
        },
        _ => true
    }
}

/// Get nth element (0-indexed).
pub fn nth(iter: Iter, n: int) -> Option<Any> {
    let skipped = skip(iter, n);
    first(skipped)
}

/// Get min element.
pub fn min(iter: Iter) -> Option<Any> {
    match first(iter) {
        Some(first_val) => {
            let rest = skip(iter, 1);
            Some(fold(rest, first_val, |acc, x| {
                if x < acc { x } else { acc }
            }))
        },
        _ => None
    }
}

/// Get max element.
pub fn max(iter: Iter) -> Option<Any> {
    match first(iter) {
        Some(first_val) => {
            let rest = skip(iter, 1);
            Some(fold(rest, first_val, |acc, x| {
                if x > acc { x } else { acc }
            }))
        },
        _ => None
    }
}
