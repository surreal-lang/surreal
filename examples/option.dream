// Option type example with generics

mod option {
    // Generic Option type
    enum Option<T> {
        Some(T),
        None,
    }

    // Safe division that returns Option<int>
    pub fn safe_div(a: int, b: int) -> Option<int> {
        if b == 0 {
            None
        } else {
            Some(a / b)
        }
    }

    // Unwrap with default (generic version)
    pub fn unwrap_or<T>(opt: Option<T>, default: T) -> T {
        match opt {
            Some(x) => x,
            None => default,
        }
    }

    // Map over Option (generic version)
    pub fn map<T, U>(opt: Option<T>, f: Fn) -> Option<U> {
        match opt {
            Some(x) => Some(f(x)),
            None => None,
        }
    }

    // Map that doubles an int
    pub fn map_double(opt: Option<int>) -> Option<int> {
        match opt {
            Some(x) => Some(x * 2),
            None => None,
        }
    }

    // Test safe_div with method chaining
    pub fn test_div() -> int {
        safe_div(10, 2).unwrap_or(0)
    }

    // Test div by zero with method chaining
    pub fn test_div_zero() -> int {
        safe_div(10, 0).unwrap_or(-1)
    }

    // Test map with method chaining
    pub fn test_map() -> int {
        Some(21).map_double().unwrap_or(0)
    }
}
