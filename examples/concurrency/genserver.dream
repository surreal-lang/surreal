// GenServer Example - Counter Server
//
// Demonstrates how to build a stateful server using the GenServer module.
// The counter module implements the GenServer trait by having the required callback functions.

mod genserver_example {
    use io::{println, format};
    use genserver::{call, cast, stop, start};

    // Convenience functions for the Counter API
    pub fn get(server: pid) -> int {
        call(server, counter::Call::Get)
    }

    pub fn get_and_increment(server: pid) -> int {
        call(server, counter::Call::GetAndIncrement)
    }

    pub fn increment(server: pid) -> atom {
        cast(server, counter::Cast::Increment)
    }

    pub fn increment_by(server: pid, n: int) -> atom {
        cast(server, counter::Cast::IncrementBy(n))
    }

    pub fn reset(server: pid) -> atom {
        cast(server, counter::Cast::Reset)
    }

    pub fn main() -> atom {
        println("=== GenServer Counter Example ===");
        println("");

        // Start the counter server using genserver::start
        // Pass the module atom :counter
        let counter_pid = start(:counter, ());
        format("Started counter server: ~p~n", [counter_pid]);

        // Get initial value
        let val0 = get(counter_pid);
        format("Initial value: ~p~n", [val0]);

        // Increment a few times
        increment(counter_pid);
        increment(counter_pid);
        increment(counter_pid);

        // Small delay to ensure casts are processed
        :timer::sleep(10);

        let val1 = get(counter_pid);
        format("After 3 increments: ~p~n", [val1]);

        // Increment by 10
        increment_by(counter_pid, 10);
        :timer::sleep(10);

        let val2 = get(counter_pid);
        format("After increment_by(10): ~p~n", [val2]);

        // Get and increment atomically
        let val3 = get_and_increment(counter_pid);
        let val4 = get(counter_pid);
        format("get_and_increment returned: ~p, next get: ~p~n", [val3, val4]);

        // Reset
        reset(counter_pid);
        :timer::sleep(10);

        let val5 = get(counter_pid);
        format("After reset: ~p~n", [val5]);

        // Stop the server
        stop(counter_pid);
        println("");
        println("Counter server stopped.");

        :ok
    }
}

mod counter {
    // Declare that this module implements the GenServer trait
    // with associated type bindings for State and message types
    impl genserver::GenServer {
        type State = int;
        type CallMsg = Call;
        type CastMsg = Cast;
    }

    // Message types for calls (synchronous)
    pub enum Call {
        Get,
        GetAndIncrement,
    }

    // Message types for casts (asynchronous)
    pub enum Cast {
        Increment,
        IncrementBy(int),
        Reset,
    }

    // GenServer callbacks
    // Required: init, handle_call, handle_cast
    // Optional: handle_info, terminate (have defaults)
    //
    // Dream supports multi-clause functions with enum pattern matching,
    // similar to Erlang/Elixir. Each variant gets its own function clause.
    //
    // With associated type bindings, we can use Self::State in signatures.

    /// Initialize the counter state
    pub fn init(args: any) -> (atom, Self::State) {
        (:ok, 0)
    }

    /// Handle synchronous calls - using multi-clause functions
    /// `from` is a From struct containing the caller's pid and reference
    pub fn handle_call(Call::Get, from: genserver::From, state: Self::State) -> (atom, Self::State, Self::State) {
        io::println("Received Get call");
        (:reply, state, state)
    }

    pub fn handle_call(Call::GetAndIncrement, from: genserver::From, state: Self::State) -> (atom, Self::State, Self::State) {
        io::println("Received GetAndIncrement call");
        (:reply, state, state + 1)
    }

    /// Handle asynchronous casts - using multi-clause functions
    pub fn handle_cast(Cast::Increment, state: Self::State) -> (atom, Self::State) {
        io::println("Received Increment cast");
        (:noreply, state + 1)
    }

    pub fn handle_cast(Cast::IncrementBy(n), state: Self::State) -> (atom, Self::State) {
        io::println(io::format("Received IncrementBy(~p) cast", [n]));
        (:noreply, state + n)
    }

    pub fn handle_cast(Cast::Reset, state: Self::State) -> (atom, Self::State) {
        io::println("Received Reset cast");
        (:noreply, 0)
    }

    // NOTE: handle_info and terminate are optional!
    // If not defined, the default implementations are used:
    // - handle_info: ignores the message, keeps state unchanged
    // - terminate: does nothing, returns :ok
}
