/// Method chaining example using UFCS
///
/// Method calls like `expr.method(args)` are transformed into
/// `method(expr, args)` where `method` must be in scope.
///
/// NOTE: UFCS currently works for structs but not enums (Option/Result).
/// For enums, use explicit qualified function calls.

/// Safe division that returns Option<int>
pub fn safe_div(a: int, b: int) -> Option<int> {
    if b == 0 {
        None
    } else {
        Some(a / b)
    }
}

pub fn main() -> atom {
    io::println("Method chaining example");
    io::println("========================");

    // For Option types, use explicit module::function calls
    let result1 = option::unwrap_or(safe_div(10, 2), 0);
    io::format("10 / 2 = ~p~n", [result1]);

    let result2 = option::unwrap_or(safe_div(10, 0), -1);
    io::format("10 / 0 = ~p (default: -1)~n", [result2]);

    // Check if option has value using stdlib
    let has_value = option::is_some(safe_div(20, 4));
    io::format("20 / 4 is_some: ~p~n", [has_value]);

    let no_value = option::is_some(safe_div(20, 0));
    io::format("20 / 0 is_some: ~p~n", [no_value]);

    // Direct Some/None
    let chained = option::unwrap_or(Some(42), 0);
    io::format("Some(42).unwrap_or(0) = ~p~n", [chained]);

    :ok
}
