// Tests for the enumerable module and Iter trait
//
// Uses Dream stdlib modules for idiomatic code.

use io::{format};
use list::{len};

// Helper to assert equality - uses any type for flexibility
fn assert_eq<T>(actual: T, expected: T, name: string) {
    if actual == expected {
        format("✓ ~s~n", [name])
    } else {
        format("✗ ~s - expected ~p, got ~p~n", [name, expected, actual])
    }
}

fn assert_true(value: bool, name: string) {
    if value {
        format("✓ ~s~n", [name])
    } else {
        format("✗ ~s - expected true~n", [name])
    }
}

fn assert_false(value: bool, name: string) {
    if !value {
        format("✓ ~s~n", [name])
    } else {
        format("✗ ~s - expected false~n", [name])
    }
}

// ============================================================================
// Enumerable module tests (for lists)
// ============================================================================

fn test_map() {
    format("~n--- map ---~n", []);

    let result = enumerable::map([1, 2, 3], |x| { x * 2 });
    assert_eq(result, [2, 4, 6], "map doubles values");

    let empty = enumerable::map([], |x| { x });
    assert_eq(empty, [], "map on empty list");
}

fn test_filter() {
    format("~n--- filter ---~n", []);

    let evens = enumerable::filter([1, 2, 3, 4, 5], |x| { x % 2 == 0 });
    assert_eq(evens, [2, 4], "filter keeps evens");

    let none = enumerable::filter([1, 3, 5], |x| { x % 2 == 0 });
    assert_eq(none, [], "filter returns empty when no matches");

    let all = enumerable::filter([2, 4, 6], |x| { x % 2 == 0 });
    assert_eq(all, [2, 4, 6], "filter keeps all when all match");
}

fn test_reduce() {
    format("~n--- reduce ---~n", []);

    let sum = enumerable::reduce([1, 2, 3, 4], 0, |x, acc| { x + acc });
    assert_eq(sum, 10, "reduce sums values");

    let product = enumerable::reduce([1, 2, 3, 4], 1, |x, acc| { x * acc });
    assert_eq(product, 24, "reduce multiplies values");

    let empty = enumerable::reduce([], 42, |x, acc| { x + acc });
    assert_eq(empty, 42, "reduce on empty list returns init");
}

fn test_find() {
    format("~n--- find ---~n", []);

    let found = enumerable::find([1, 2, 3, 4, 5], |x| { x > 3 });
    assert_eq(found, Some(4), "find returns first match");

    let not_found = enumerable::find([1, 2, 3], |x| { x > 10 });
    assert_eq(not_found, None, "find returns None when no match");
}

fn test_any_all() {
    format("~n--- any/all ---~n", []);

    let has_even = enumerable::any([1, 2, 3], |x| { x % 2 == 0 });
    assert_true(has_even, "any finds even");

    let no_negative = enumerable::any([1, 2, 3], |x| { x < 0 });
    assert_false(no_negative, "any returns false when none match");

    let all_positive = enumerable::all([1, 2, 3], |x| { x > 0 });
    assert_true(all_positive, "all positive");

    let not_all_even = enumerable::all([1, 2, 3], |x| { x % 2 == 0 });
    assert_false(not_all_even, "not all even");
}

fn test_count() {
    format("~n--- count ---~n", []);

    let num_evens = enumerable::count([1, 2, 3, 4, 5], |x| { x % 2 == 0 });
    assert_eq(num_evens, 2, "count evens");

    let total = enumerable::count_all([1, 2, 3, 4, 5]);
    assert_eq(total, 5, "count_all");
}

fn test_take_drop() {
    format("~n--- take/drop ---~n", []);

    let first_3 = enumerable::take([1, 2, 3, 4, 5], 3);
    assert_eq(first_3, [1, 2, 3], "take first 3");

    let after_3 = enumerable::drop([1, 2, 3, 4, 5], 3);
    assert_eq(after_3, [4, 5], "drop first 3");

    let take_zero = enumerable::take([1, 2, 3], 0);
    assert_eq(take_zero, [], "take 0");
}

fn test_zip() {
    format("~n--- zip ---~n", []);

    let zipped = enumerable::zip([1, 2, 3], ["a", "b", "c"]);
    assert_eq(zipped, [(1, "a"), (2, "b"), (3, "c")], "zip two lists");
}

fn test_flat_map() {
    format("~n--- flat_map ---~n", []);

    let expanded = enumerable::flat_map([1, 2, 3], |x| { [x, x * 10] });
    assert_eq(expanded, [1, 10, 2, 20, 3, 30], "flat_map expands");
}

fn test_reverse() {
    format("~n--- reverse ---~n", []);

    let rev = enumerable::reverse([1, 2, 3]);
    assert_eq(rev, [3, 2, 1], "reverse list");

    let empty = enumerable::reverse([]);
    assert_eq(empty, [], "reverse empty");
}

fn test_range() {
    format("~n--- range ---~n", []);

    let r = enumerable::range(1, 5);
    assert_eq(r, [1, 2, 3, 4, 5], "range 1 to 5");

    let stepped = enumerable::range_step(0, 10, 2);
    assert_eq(stepped, [0, 2, 4, 6, 8, 10], "range with step 2");
}

fn test_uniq() {
    format("~n--- uniq ---~n", []);

    let unique = enumerable::uniq([1, 2, 2, 3, 3, 3, 4]);
    assert_eq(unique, [1, 2, 3, 4], "uniq removes duplicates");
}

fn test_chunk() {
    format("~n--- chunk ---~n", []);

    let chunks = enumerable::chunk([1, 2, 3, 4, 5, 6], 2);
    assert_eq(chunks, [[1, 2], [3, 4], [5, 6]], "chunk by 2");
}

fn test_sum() {
    format("~n--- sum ---~n", []);

    let total = enumerable::sum([1, 2, 3, 4, 5]);
    assert_eq(total, 15, "sum");

    let empty_sum = enumerable::sum([]);
    assert_eq(empty_sum, 0, "sum of empty");
}

fn test_max_min() {
    format("~n--- max/min ---~n", []);

    let maximum = enumerable::max([3, 1, 4, 1, 5, 9, 2, 6]);
    assert_eq(maximum, 9, "max");

    let minimum = enumerable::min([3, 1, 4, 1, 5, 9, 2, 6]);
    assert_eq(minimum, 1, "min");
}

// ============================================================================
// Iter trait tests (for Map)
// ============================================================================

// This Map implementation demonstrates FFI interop for wrapping Erlang
// data structures. Direct :maps:: and :lists:: calls are used here to show
// how to build high-level abstractions on top of Erlang primitives.
// For production code, prefer using stdlib/map.dream instead.

pub struct Map {
    data: map,
}

impl Map {
    pub fn new() -> Map {
        Map { data: :maps::new() }
    }

    pub fn put<K, V>(self, key: K, value: V) -> Map {
        Map { data: :maps::put(key, value, self.data) }
    }

    pub fn to_list<K, V>(self) -> [(K, V)] {
        :maps::to_list(self.data)
    }

    pub fn map<K, V, U>(self, f: fn((K, V)) -> U) -> [U] {
        :lists::map(f, :maps::to_list(self.data))
    }

    pub fn filter<K, V>(self, pred: fn((K, V)) -> bool) -> [(K, V)] {
        :lists::filter(pred, :maps::to_list(self.data))
    }

    pub fn reduce<K, V, Acc>(self, init: Acc, f: fn((K, V), Acc) -> Acc) -> Acc {
        :lists::foldl(f, init, :maps::to_list(self.data))
    }

    pub fn any<K, V>(self, pred: fn((K, V)) -> bool) -> bool {
        :lists::any(pred, :maps::to_list(self.data))
    }

    pub fn all<K, V>(self, pred: fn((K, V)) -> bool) -> bool {
        :lists::all(pred, :maps::to_list(self.data))
    }

    pub fn count<K, V>(self, pred: fn((K, V)) -> bool) -> int {
        len(:lists::filter(pred, :maps::to_list(self.data)))
    }
}

fn test_map_to_list() {
    format("~n--- Map.to_list ---~n", []);

    let m = Map::new();
    let m = m.put("a", 1);
    let m = m.put("b", 2);

    let entries = m.to_list();
    let len = len(entries);
    assert_eq(len, 2, "map has 2 entries");
}

fn test_map_filter() {
    format("~n--- Map.filter ---~n", []);

    let m = Map::new();
    let m = m.put("alice", 30);
    let m = m.put("bob", 25);
    let m = m.put("charlie", 35);

    let seniors = m.filter(|entry| {
        let age = :erlang::element(2, entry);
        age >= 30
    });

    let count = len(seniors);
    assert_eq(count, 2, "filter age >= 30");
}

fn test_map_map() {
    format("~n--- Map.map ---~n", []);

    let m = Map::new();
    let m = m.put("a", 1);
    let m = m.put("b", 2);
    let m = m.put("c", 3);

    let values = m.map(|entry| {
        :erlang::element(2, entry)
    });

    let sum = enumerable::sum(values);
    assert_eq(sum, 6, "map extracts values and sum is 6");
}

fn test_map_reduce() {
    format("~n--- Map.reduce ---~n", []);

    let m = Map::new();
    let m = m.put("a", 10);
    let m = m.put("b", 20);
    let m = m.put("c", 30);

    let total = m.reduce(0, |entry, acc| {
        acc + :erlang::element(2, entry)
    });

    assert_eq(total, 60, "reduce sums values");
}

fn test_map_any_all() {
    format("~n--- Map.any/all ---~n", []);

    let m = Map::new();
    let m = m.put("a", 10);
    let m = m.put("b", 20);
    let m = m.put("c", 30);

    let has_big = m.any(|entry| {
        :erlang::element(2, entry) > 25
    });
    assert_true(has_big, "any > 25");

    let all_positive = m.all(|entry| {
        :erlang::element(2, entry) > 0
    });
    assert_true(all_positive, "all > 0");
}

fn test_map_count() {
    format("~n--- Map.count ---~n", []);

    let m = Map::new();
    let m = m.put("a", 10);
    let m = m.put("b", 20);
    let m = m.put("c", 30);

    let big_count = m.count(|entry| {
        :erlang::element(2, entry) >= 20
    });

    assert_eq(big_count, 2, "count >= 20");
}

// ============================================================================
// Main
// ============================================================================

pub fn main() -> atom {
    format("=== Enumerable Module Tests ===~n", []);

    // List tests
    test_map();
    test_filter();
    test_reduce();
    test_find();
    test_any_all();
    test_count();
    test_take_drop();
    test_zip();
    test_flat_map();
    test_reverse();
    test_range();
    test_uniq();
    test_chunk();
    test_sum();
    test_max_min();

    format("~n=== Iter Trait Tests (Map) ===~n", []);

    // Map Iter tests
    test_map_to_list();
    test_map_filter();
    test_map_map();
    test_map_reduce();
    test_map_any_all();
    test_map_count();

    format("~n=== All tests complete ===~n", []);
    :ok
}
