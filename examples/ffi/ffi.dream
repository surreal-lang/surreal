// FFI example - calling Erlang/OTP functions from Dream
//
// NOTE: For most use cases, prefer Dream stdlib modules:
//   use list::{reverse, head, tail};
//   use enumerable::{map, filter, reduce};
//
// Direct FFI calls are available for advanced use cases.

pub fn main() -> atom {
    // Demonstrate FFI calls to Erlang
    // Note: FFI return types are inferred as 'any' - no type annotation needed
    let abs_val = :erlang::abs(-42);
    io::format("abs(-42) = ~p~n", [abs_val]);

    let max_val = max_value(10, 20);
    io::format("max(10, 20) = ~p~n", [max_val]);

    let reversed = reverse_list([1, 2, 3, 4, 5]);
    io::format("reverse([1,2,3,4,5]) = ~p~n", [reversed]);

    :ok
}

pub fn reverse_list(items: [int]) -> [int] {
    // Use Dream stdlib list::reverse instead of :lists::reverse
    list::reverse(items)
}

pub fn max_value(a: int, b: int) -> int {
    // For max/min, :erlang:: FFI is fine until we have a math stdlib
    :erlang::max(a, b)
}
