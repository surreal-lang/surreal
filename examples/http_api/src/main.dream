// HTTP API Example
// Uses cowboy (Erlang) for HTTP server

/// Application module - implements OTP application behavior
mod http_api {
    use io::println;

    /// OTP Application start callback
    /// Called automatically when the application starts
    pub fn start(_type: atom, _args: [any]) -> Result<pid, any> {
        let dispatch = compile_routes();

        // Build the options map using maps::put
        let env_map = :maps::put(:dispatch, dispatch, :maps::new());
        let opts = :maps::put(:env, env_map, :maps::new());

        // Start cowboy HTTP listener
        match :cowboy::start_clear(:http_listener, [(:port, 8080)], opts) {
            (:ok, pid) => {
                println("Server started on http://localhost:8080");
                println("Try: curl http://localhost:8080/api/hello");
                println("     curl http://localhost:8080/api/users");

                Ok(pid)
            },
            (:error, reason) => Err(reason),
            _ => Err(:unknown_error)
        }
    }

    /// OTP Application stop callback
    pub fn stop(_state: any) -> atom {
        :cowboy::stop_listener(:http_listener);
        :ok
    }

    /// Compile cowboy routes
    fn compile_routes() -> any {
        // Build route list using lists:append to avoid type checker issues
        let r1 = ("/api/hello", :hello_handler, []);
        let r2 = ("/api/users", :users_handler, []);
        let r3 = (:_, :not_found_handler, []);
        let routes = :lists::append([r1], :lists::append([r2], [r3]));
        let host_routes = (:_, routes);
        :cowboy_router::compile([host_routes])
    }
}

/// Handler for GET /api/hello
mod hello_handler {
    /// Convert a string (charlist) to binary for JSON encoding
    fn to_binary(s: string) -> any {
        :erlang::iolist_to_binary([s])
    }

    pub fn init(req: any, state: any) -> (atom, any, any) {
        // Build a map for JSON response
        let message = to_binary("Hello from Dream!");
        let data = :maps::put(:message, message, :maps::new());
        match :"Elixir.Jason"::encode(data) {
            (:ok, json) => {
                let headers = :maps::put("content-type", "application/json", :maps::new());
                let req2 = :cowboy_req::reply(200, headers, json, req);
                (:ok, req2, state)
            },
            _ => {
                let headers = :maps::put("content-type", "text/plain", :maps::new());
                let req2 = :cowboy_req::reply(500, headers, "JSON encoding error", req);
                (:ok, req2, state)
            }
        }
    }
}

/// Handler for GET /api/users
mod users_handler {
    /// Convert a string (charlist) to binary for JSON encoding
    fn to_binary(s: string) -> any {
        :erlang::iolist_to_binary([s])
    }

    pub fn init(req: any, state: any) -> (atom, any, any) {
        // Build a list of user maps for JSON response
        let user1 = :maps::put(:name, to_binary("Alice"), :maps::put(:id, 1, :maps::new()));
        let user2 = :maps::put(:name, to_binary("Bob"), :maps::put(:id, 2, :maps::new()));
        let user3 = :maps::put(:name, to_binary("Charlie"), :maps::put(:id, 3, :maps::new()));
        let data = :maps::put(:users, [user1, user2, user3], :maps::new());
        match :"Elixir.Jason"::encode(data) {
            (:ok, json) => {
                let headers = :maps::put("content-type", "application/json", :maps::new());
                let req2 = :cowboy_req::reply(200, headers, json, req);
                (:ok, req2, state)
            },
            _ => {
                let headers = :maps::put("content-type", "text/plain", :maps::new());
                let req2 = :cowboy_req::reply(500, headers, "JSON encoding error", req);
                (:ok, req2, state)
            }
        }
    }
}

/// Handler for 404 Not Found
mod not_found_handler {
    pub fn init(req: any, state: any) -> (atom, any, any) {
        let path = :cowboy_req::path(req);
        let body = :io_lib::format("Not Found: ~s", [path]);
        let headers = :maps::put("content-type", "text/plain", :maps::new());
        let req2 = :cowboy_req::reply(404, headers, body, req);
        (:ok, req2, state)
    }
}
