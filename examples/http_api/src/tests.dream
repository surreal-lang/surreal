// Tests for http_api
// Only compiled when running `dream test`

// Define a local test struct to avoid cross-module method resolution issues
struct TestUser {
    id: int,
    name: string,
}

impl TestUser {
    fn to_json(self) -> any {
        let map = :maps::new();
        let map = :maps::put(:id, self.id, map);
        let map = :maps::put(:name, self.name, map);
        map
    }
}

#[test]
pub fn test_user_to_json() -> atom {
    // Create a user and convert to JSON map
    let user = TestUser { id: 42, name: "Alice" };
    let json = user.to_json();

    // Check that the map has the correct keys and values
    let id = :maps::get(:id, json);
    let name = :maps::get(:name, json);

    if id != 42 {
        :erlang::error((:wrong_id, id))
    } else {
        if name != "Alice" {
            :erlang::error((:wrong_name, name))
        } else {
            :ok
        }
    }
}

#[test]
pub fn test_map_to_json_compatible() -> atom {
    // Test that to_json returns a map compatible with JSON encoding
    let user = TestUser { id: 1, name: "Bob" };
    let map = user.to_json();

    // Verify the map has the expected structure
    let has_id = :maps::is_key(:id, map);
    let has_name = :maps::is_key(:name, map);

    if has_id && has_name {
        :ok
    } else {
        :erlang::error(:missing_keys)
    }
}

#[test]
pub fn test_addition() -> atom {
    let result = 1 + 1;
    if result != 2 {
        :erlang::error(:assertion_failed)
    } else {
        :ok
    }
}

#[test]
pub fn test_list_operations() -> atom {
    let list = [1, 2, 3];
    let len = :erlang::length(list);
    if len != 3 {
        :erlang::error(:wrong_length)
    } else {
        :ok
    }
}

#[test]
pub fn test_map_operations() -> atom {
    let map = :maps::new();
    let map = :maps::put(:key, "value", map);
    match :maps::get(:key, map) {
        "value" => :ok,
        _ => :erlang::error(:wrong_value)
    }
}
