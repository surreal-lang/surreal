{"id":"toybeam-051","title":"Implement quote/unquote macro syntax (Phase 2)","description":"Phase 2 of the macro system: implement quote/unquote blocks and BEAM shell-out for user-defined macros.\n\nDepends on Phase 1 (now complete): declarative derive macros\n\nImplementation:\n- Add quote/unquote syntax to parser\n- Implement AST serialization/deserialization to Erlang terms\n- Create BEAM MacroExpander process (like REPL eval server)\n- Support #[macro] attribute for user-defined macros\n- Enable user-defined derive macros","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-12T20:42:23.852576-06:00","updated_at":"2026-01-13T11:07:19.233161-06:00","closed_at":"2026-01-13T11:07:19.233161-06:00","close_reason":"Phase 2 complete: quote/unquote syntax, AST serialization, BEAM communication, MacroRegistry. Remaining: AST deserialization for full user-defined macros."}
{"id":"toybeam-058","title":"REPL multiline input support","description":"Detect incomplete expressions (unclosed braces, trailing operators) and continue reading on next line","status":"open","priority":3,"issue_type":"feature","created_at":"2026-01-11T12:04:14.25483-06:00","updated_at":"2026-01-11T12:04:14.25483-06:00"}
{"id":"toybeam-09k","title":"Interactive shell (REPL) like iex","description":"Add an interactive shell for Dream, similar to Elixir's iex.\n\nFeatures:\n- Compile and evaluate expressions on the fly\n- Load modules into the shell\n- Tab completion\n- History\n- Helper commands (.help, .clear, etc.)\n- Ability to connect to running nodes\n\nCommand: `dream shell` or `dream repl`","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-10T09:46:50.316859-06:00","updated_at":"2026-01-11T12:04:35.746168-06:00","closed_at":"2026-01-11T12:04:35.746168-06:00","close_reason":"Core REPL functionality complete: expression eval, bindings, tab completion, history, commands (:help/:quit/:clear/:bindings/:reload/:edit/:load), miette errors, real-time spawn output. Nice-to-have features tracked separately."}
{"id":"toybeam-0bi","title":"Unlink and demonitor","description":"Add ability to remove links and monitors.\n\n## Requirements\n\n- `Unlink { target }` - remove bidirectional link\n- `Demonitor { ref }` - cancel a monitor by its reference\n- Monitor instruction should return a reference for later cancellation\n\n## Changes Needed\n\n- `Monitor` instruction needs to store monitor ref in dest register\n- Track monitors by ref, not just by target pid\n- `Value::MonitorRef(u64)` or reuse `Value::Ref`","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-02T08:11:50.331397-06:00","updated_at":"2026-01-02T18:41:06.576024-06:00","closed_at":"2026-01-02T18:41:06.576024-06:00","close_reason":"Added Unlink instruction for removing bidirectional links and Demonitor for canceling monitors by ref. Monitor now returns a ref in dest register. Updated Process to track monitors with refs on both sides.","labels":["vm"],"dependencies":[{"issue_id":"toybeam-0bi","depends_on_id":"toybeam-mje","type":"blocks","created_at":"2026-01-02T08:13:15.208106-06:00","created_by":"daemon"}]}
{"id":"toybeam-0g4","title":"Generics (type parameters)","description":"Add support for generic type parameters like `Option\u003cT\u003e` and `Result\u003cT, E\u003e`.\n\n## Current State\nEnums work but require concrete types:\n```rust\nenum Option {\n    Some(int),\n    None,\n}\n```\n\n## Desired\n```rust\nenum Option\u003cT\u003e {\n    Some(T),\n    None,\n}\n\nenum Result\u003cT, E\u003e {\n    Ok(T),\n    Err(E),\n}\n\nfn map\u003cT, U\u003e(opt: Option\u003cT\u003e, f: fn(T) -\u003e U) -\u003e Option\u003cU\u003e {\n    match opt {\n        Some(x) =\u003e Some(f(x)),\n        None =\u003e None,\n    }\n}\n```\n\n## Implementation Areas\n1. **Lexer/Parser**: Parse `\u003cT\u003e` type parameter syntax\n2. **AST**: Add `type_params` to EnumDef, StructDef, Function\n3. **Type System**: Generic type representation and instantiation\n4. **Codegen**: Monomorphization or type erasure strategy\n\n## Notes\n- BEAM/Erlang is dynamically typed, so runtime representation doesn't change\n- Main benefit is compile-time type checking and better ergonomics\n- Could start with simple monomorphization (generate code per instantiation)","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-02T17:51:54.532908-06:00","updated_at":"2026-01-02T19:43:12.732098-06:00","closed_at":"2026-01-02T19:43:12.732098-06:00","close_reason":"Added generic type parameters to parser. Functions, structs, and enums can now declare type params like \u003cT, U\u003e. Type annotations support type args like Option\u003cint\u003e. 5 new parser tests."}
{"id":"toybeam-0ua","title":"Type aliases (type Result = :ok | :error)","description":"Add type alias support to Dream.\n\nSyntax:\n  type Result = :ok | :error;\n  type UserId = int;\n  type Handler = fn(int) -\u003e string;\n  type Result\u003cT\u003e = (:ok, T) | :error;  // generic aliases\n\nImplementation:\n1. Parser: parse 'type Name = Type;' and 'type Name\u003cT\u003e = Type;'\n2. AST: Add TypeAlias item\n3. Type checker: Resolve aliases during type checking\n4. Support generic type aliases with type parameters","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-08T17:55:17.649097-06:00","updated_at":"2026-01-08T18:04:27.839685-06:00","closed_at":"2026-01-08T18:04:27.839685-06:00","close_reason":"Type aliases implemented: AST, parser, type checker resolution, 7 parser tests, 6 type checker tests, example file"}
{"id":"toybeam-0yu","title":"Add type-directed method resolution for stdlib","description":"","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-04T09:48:35.168172-06:00","updated_at":"2026-01-04T10:29:24.999719-06:00","closed_at":"2026-01-04T10:29:24.999719-06:00","close_reason":"Implemented type-directed method resolution. Added resolved_module field to MethodCall AST, resolution pass in typeck.rs, and codegen support. s.trim().to_upper() now resolves to string::trim and string::to_upper without imports.","dependencies":[{"issue_id":"toybeam-0yu","depends_on_id":"toybeam-wqi","type":"blocks","created_at":"2026-01-04T09:49:32.655117-06:00","created_by":"scrogson"}]}
{"id":"toybeam-1om","title":"Improve REPL performance with persistent BEAM process","description":"Current REPL spawns erlc + erl for each expression, which is slow. Should maintain a persistent BEAM process and send code to evaluate via stdin/stdout protocol. This would make evaluation near-instantaneous after initial startup.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-10T21:46:59.587951-06:00","updated_at":"2026-01-10T21:54:47.851076-06:00","closed_at":"2026-01-10T21:54:47.851076-06:00","close_reason":"Implemented persistent BEAM process - 10 evals in 0.4s total"}
{"id":"toybeam-1wx","title":"Create stdlib/io module","description":"Implement io module with println, print, format functions using FFI to erlang:io","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-03T15:43:28.468392-06:00","updated_at":"2026-01-03T15:54:07.716215-06:00","closed_at":"2026-01-03T15:54:07.716215-06:00","close_reason":"Initial implementation complete - modules compile successfully"}
{"id":"toybeam-2c2","title":"String interpolation with {var} syntax","description":"Support Rust-like string interpolation: \"Hello {name}!\" compiles to string concatenation or io_lib:format equivalent","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-08T18:47:32.419359-06:00","updated_at":"2026-01-09T05:26:14.219673-06:00","closed_at":"2026-01-09T05:26:14.219673-06:00","close_reason":"Implemented string interpolation with {expr} syntax. Strings like \"Hello {name}!\" now work. Uses erlang:iolist_to_binary with display::to_string for conversion."}
{"id":"toybeam-2id","title":"Unit type design and :ok semantics","description":"","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-08T18:31:27.859965-06:00","updated_at":"2026-01-08T18:40:44.772277-06:00","closed_at":"2026-01-08T18:40:44.772277-06:00","close_reason":"Result compiles to Erlang conventions: Ok(()) → :ok, Ok(val) → {:ok, val}, Err(e) → {:error, e}"}
{"id":"toybeam-2of","title":"Store inferred types during type checking","description":"The type checker infers types but doesn't store them for later passes. Add a HashMap\u003cSpan, Ty\u003e or similar to record the inferred type of each expression. This enables later passes to make type-directed decisions.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-04T09:48:50.641459-06:00","updated_at":"2026-01-04T10:29:24.99737-06:00","closed_at":"2026-01-04T10:29:24.99737-06:00","close_reason":"Implemented type-directed method resolution. Added resolved_module field to MethodCall AST, resolution pass in typeck.rs, and codegen support. s.trim().to_upper() now resolves to string::trim and string::to_upper without imports."}
{"id":"toybeam-2s3","title":"Type checker - semantic analysis pass","description":"Add a type checking phase that validates:\n- Function parameter and return types match usage\n- Struct field types are respected\n- Enum variant types are correct\n- Type annotations on let bindings are verified\n- Method calls have correct receiver types\n\nThis is foundational for making generics meaningful.","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-03T22:35:04.26421-06:00","updated_at":"2026-01-03T22:47:29.720248-06:00","closed_at":"2026-01-03T22:47:29.720248-06:00","close_reason":"Implemented type checker with semantic analysis. Validates function signatures, expressions, patterns. Integrated into compile pipeline as warnings. Generics support is foundational - full generic type substitution requires follow-up work."}
{"id":"toybeam-2s6","title":"Selective receive optimization","description":"","status":"open","priority":3,"issue_type":"feature","created_at":"2026-01-02T19:54:00.780558-06:00","updated_at":"2026-01-02T19:54:00.780558-06:00"}
{"id":"toybeam-3b8","title":"Add let else pattern matching syntax","description":"Rust-style let else for early returns: let Some(x) = expr else { return; }; Desugars to case with pattern arm and wildcard arm.","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-15T22:38:22.376112-06:00","updated_at":"2026-01-15T22:38:33.425756-06:00","closed_at":"2026-01-15T22:38:33.425756-06:00","close_reason":"Implemented - desugars to case expression with pattern arm and wildcard fallback arm"}
{"id":"toybeam-3e5","title":"Add Term enum for type-safe dynamic values","description":"Add a Term sum type for type-safe handling of dynamic Erlang values. Coexists with 'any' - they serve different purposes:\n\n- `any`: bypass type system, opaque pass-through (FFI, generic containers)\n- `Term`: inspect dynamic values with exhaustive pattern matching\n\n```dream\npub enum Term {\n    Atom(atom),\n    Int(int),\n    Float(float),\n    String(string),\n    Binary(binary),\n    List([Term]),\n    Tuple(tuple),\n    Map(map),\n    Pid(pid),\n    Ref(ref),\n    Fun(fn),\n}\n\n// Example: type-safe message handling\nfn handle(msg: Term) -\u003e string {\n    match msg {\n        Term::Atom(a) =\u003e atom_to_string(a),\n        Term::Int(n) =\u003e int_to_string(n),\n        Term::List(items) =\u003e format_list(items),\n        _ =\u003e \"unknown\"\n    }\n}\n```\n\nBenefits: exhaustiveness checking, clearer FFI boundaries, better error messages.","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-15T21:32:13.658529-06:00","updated_at":"2026-01-15T22:59:54.373909-06:00","closed_at":"2026-01-15T22:59:54.373909-06:00","close_reason":"Implemented Term enum in stdlib/term.dream with from_any/to_any conversion and type-safe pattern matching"}
{"id":"toybeam-3f1","title":"stdlib/keyword - Keyword lists","description":"Implement Keyword module for ordered key-value pairs (list of tuples). get, put, delete, keys, values, merge, has_key, to_map. Used for options/config.","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-03T20:52:19.902754-06:00","updated_at":"2026-01-15T21:24:26.120481-06:00","closed_at":"2026-01-15T21:24:26.120481-06:00","close_reason":"Implemented keyword module with: get, get_or, get_all, put, put_new, replace, delete, delete_all, has_key, keys, values, merge, merge_unique, unique_keys, to_map, from_map, len, is_empty, take, drop"}
{"id":"toybeam-3ge","title":"Match exhaustiveness checking","description":"","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-08T18:31:00.858713-06:00","updated_at":"2026-01-09T07:45:07.299876-06:00","closed_at":"2026-01-09T07:45:07.299876-06:00","close_reason":"Implemented match exhaustiveness checking"}
{"id":"toybeam-3gz","title":"Design macro system for Dream","description":"Explore and design a macro system combining the best of Rust and Elixir approaches.\n\n## Inspirations\n\n### Elixir (Lisp-like AST)\n- Homoiconic: code is data (3-tuples: {atom, metadata, args})\n- quote/unquote for AST construction and interpolation\n- Macros are functions that receive AST and return AST\n- Hygienic by default\n- Compile-time execution in the same runtime\n\n### Rust Attribute Macros\n- #[derive(Debug, Clone, Serialize)] - derive traits automatically\n- #[serde(rename_all = \"camelCase\")] - configure behavior declaratively\n- #[tokio::main] - transform function signatures\n- Powerful for boilerplate elimination and DSLs\n\n---\n\n## AST Representation Design\n\n### Core Principle: Uniform 3-Tuple Structure\n\nEvery AST node is a 3-tuple: `(kind, meta, data)`\n- `kind`: Atom identifying the node type\n- `meta`: Map with source location (`line`, `column`, `file`)\n- `data`: Node-specific payload (tuple, list, or literal)\n\nThis compiles naturally to Erlang terms and is easy to pattern match.\n\n### Literal Nodes\n\n```\n(:int, meta, 42)\n(:float, meta, 3.14)\n(:string, meta, \"hello\")\n(:atom, meta, :foo)\n(:bool, meta, true)\n```\n\n### Identifiers\n\n```\n(:ident, meta, \"x\")\n(:path, meta, [\"string\", \"reverse\"])\n```\n\n### Expressions\n\n```\n(:binary, meta, (:+, left_ast, right_ast))\n(:unary, meta, (:-, expr_ast))\n(:call, meta, (func_ast, [arg_ast, ...]))\n(:method_call, meta, (receiver_ast, \"method\", [arg_ast, ...]))\n(:pipe, meta, (left_ast, right_ast))\n(:block, meta, [stmt_ast, ...])\n(:tuple, meta, [elem_ast, ...])\n(:list, meta, [elem_ast, ...])\n(:map, meta, [(key_ast, val_ast), ...])\n```\n\n### Bindings \u0026 Control Flow\n\n```\n(:let, meta, (pattern_ast, value_ast))\n(:if, meta, (cond_ast, then_ast, else_ast))\n(:match, meta, (expr_ast, [arm_ast, ...]))\n(:arm, meta, (pattern_ast, guard_ast | :none, body_ast))\n(:receive, meta, ([arm_ast, ...], timeout_ast | :none))\n```\n\n### Patterns\n\n```\n(:wildcard, meta, ())\n(:var_pattern, meta, \"x\")\n(:tuple_pattern, meta, [pattern_ast, ...])\n(:list_pattern, meta, [pattern_ast, ...])\n(:cons_pattern, meta, (head_ast, tail_ast))\n(:struct_pattern, meta, (\"Point\", [(\"x\", pat), (\"y\", pat)]))\n```\n\n### Definitions\n\n```\n// Function\n(:fn, meta, (\n    \"function_name\",\n    [(:param, meta, (\"x\", type_ast | :none)), ...],\n    return_type_ast | :none,\n    body_ast\n))\n\n// Struct\n(:struct, meta, (\n    \"Point\",\n    [(:field, meta, (\"x\", type_ast)), ...],\n    [type_param, ...]\n))\n\n// Enum\n(:enum, meta, (\n    \"Option\",\n    [(:variant, meta, (\"Some\", [type_ast])), (:variant, meta, (\"None\", []))],\n    [type_param, ...]\n))\n\n// Impl block\n(:impl, meta, (\n    type_ast,\n    trait_ast | :none,\n    [fn_ast, ...]\n))\n```\n\n### Types\n\n```\n(:type_name, meta, \"Int\")\n(:type_generic, meta, (\"Option\", [type_ast]))\n(:type_tuple, meta, [type_ast, ...])\n(:type_fn, meta, ([param_type, ...], return_type))\n(:type_union, meta, [type_ast, ...])\n```\n\n### Attributes\n\n```\n(:attr, meta, (\"derive\", [arg_ast, ...]))\n\n// #[derive(Debug, Clone)]\n// struct Point { x: Int }\n//\n// becomes:\n(:attributed, meta, (\n    [(:attr, meta, (\"derive\", [(:atom, _, :Debug), (:atom, _, :Clone)]))],\n    (:struct, meta, ...)\n))\n```\n\n---\n\n## Example: Code to AST\n\n```rust\n// Dream code:\nlet x = 1 + 2\n\n// AST representation:\n(:let, #{line: 1, col: 1}, (\n    (:var_pattern, #{line: 1, col: 5}, \"x\"),\n    (:binary, #{line: 1, col: 9}, (\n        :+,\n        (:int, #{line: 1, col: 9}, 1),\n        (:int, #{line: 1, col: 13}, 2)\n    ))\n))\n```\n\n```rust\n// Dream code:\nfn add(a: Int, b: Int) -\u003e Int {\n    a + b\n}\n\n// AST representation:\n(:fn, #{line: 1}, (\n    \"add\",\n    [\n        (:param, #{}, (\"a\", (:type_name, #{}, \"Int\"))),\n        (:param, #{}, (\"b\", (:type_name, #{}, \"Int\")))\n    ],\n    (:type_name, #{}, \"Int\"),\n    (:binary, #{line: 2}, (:+, (:ident, #{}, \"a\"), (:ident, #{}, \"b\")))\n))\n```\n\n---\n\n## Quote/Unquote Syntax\n\n```rust\n// quote captures code as AST data\nlet ast = quote {\n    1 + 2\n};\n// ast = (:binary, #{}, (:+, (:int, #{}, 1), (:int, #{}, 2)))\n\n// unquote splices runtime values into quoted AST\nlet x = 10;\nlet ast = quote {\n    unquote(x) + 2\n};\n// ast = (:binary, #{}, (:+, (:int, #{}, 10), (:int, #{}, 2)))\n\n// unquote_splicing for injecting lists\nlet args = [quote { a }, quote { b }];\nlet ast = quote {\n    foo(unquote_splicing(args))\n};\n// ast = (:call, #{}, ((:ident, #{}, \"foo\"), [(:ident, #{}, \"a\"), (:ident, #{}, \"b\")]))\n```\n\n---\n\n## Macro Definition Sketch\n\n```rust\n#[macro]\nfn unless(condition: Ast, body: Ast) -\u003e Ast {\n    quote {\n        if \\!unquote(condition) {\n            unquote(body)\n        }\n    }\n}\n\n// Usage:\nunless x \u003e 10 {\n    io::println(\"x is small\")\n}\n\n// Expands to:\nif \\!(x \u003e 10) {\n    io::println(\"x is small\")\n}\n```\n\n```rust\n#[macro]\nfn derive_debug(item: Ast) -\u003e Ast {\n    match item {\n        (:struct, meta, (name, fields, type_params)) =\u003e {\n            let field_formats = fields\n                |\u003e Ast::map(|(:field, _, (fname, _))| {\n                    quote { \"{}: {:?}\", self.unquote(Ast::ident(fname)) }\n                });\n            \n            quote {\n                impl Debug for unquote(Ast::ident(name)) {\n                    fn fmt(self, f: Formatter) -\u003e Result\u003c(), Error\u003e {\n                        write\\!(f, unquote_splicing(field_formats))\n                    }\n                }\n            }\n        }\n        _ =\u003e panic\\!(\"derive_debug only works on structs\")\n    }\n}\n```\n\n---\n\n## Macro Execution via BEAM Shell-Out\n\nSince Dream's compiler is written in Rust but macros need to execute Dream code,\nwe shell out to BEAM for macro expansion (similar to REPL eval).\n\n### Architecture\n\n```\n    Dream Source                     Rust Compiler                    BEAM Process\n    ────────────                     ─────────────                    ────────────\n         │                                │                                │\n         │  #[macro]                      │                                │\n         │  fn unless(...) { ... }        │                                │\n         │                                │                                │\n         ├───────────────────────────────\u003e│                                │\n         │                                │                                │\n         │                          ┌─────┴─────┐                          │\n         │                          │  Compile  │                          │\n         │                          │  macro to │                          │\n         │                          │  BEAM     │                          │\n         │                          └─────┬─────┘                          │\n         │                                │                                │\n         │                                │──── dream::macros.beam ───────\u003e│\n         │                                │     (loaded once)              │\n         │                                │                                │\n         │  unless x \u003e 10 { ... }         │                                │\n         │                                │                                │\n         ├───────────────────────────────\u003e│                                │\n         │                                │                                │\n         │                          ┌─────┴─────┐                          │\n         │                          │  Serialize│                          │\n         │                          │  AST to   │                          │\n         │                          │  Erlang   │                          │\n         │                          └─────┬─────┘                          │\n         │                                │                                │\n         │                                │  expand:unless:\u003cast_base64\u003e    │\n         │                                ├───────────────────────────────\u003e│\n         │                                │                                │\n         │                                │                          ┌─────┴─────┐\n         │                                │                          │  Execute  │\n         │                                │                          │  macro fn │\n         │                                │                          │  with AST │\n         │                                │                          └─────┬─────┘\n         │                                │                                │\n         │                                │\u003c───────────────────────────────┤\n         │                                │  ok:\u003ctransformed_ast_base64\u003e   │\n         │                                │                                │\n         │                          ┌─────┴─────┐                          │\n         │                          │ Deserialize│                         │\n         │                          │ back to    │                         │\n         │                          │ Rust AST   │                         │\n         │                          └─────┬─────┘                          │\n         │                                │                                │\n         │                          ┌─────┴─────┐                          │\n         │                          │  Continue │                          │\n         │                          │  compiling│                          │\n         │                          └───────────┘                          │\n```\n\n### Macro Expansion Server (Erlang)\n\n```erlang\n-module('dream::macro_server').\n-export([start/0]).\n\nstart() -\u003e\n    Loop = fun Loop() -\u003e\n        case io:get_line(\"\") of\n            eof -\u003e ok;\n            Line -\u003e\n                Cmd = string:trim(Line),\n                case string:prefix(Cmd, \"expand:\") of\n                    nomatch -\u003e \n                        io:format(\"\\x00DREAM_RESULT\\x00\\nerr:unknown_command\\n\"),\n                        Loop();\n                    Rest -\u003e\n                        [MacroName, AstBase64] = string:split(Rest, \":\", leading),\n                        Result = try\n                            Ast = binary_to_term(base64:decode(AstBase64)),\n                            MacroMod = 'dream::macros',\n                            MacroFun = list_to_atom(MacroName),\n                            Expanded = MacroMod:MacroFun(Ast),\n                            {ok, base64:encode(term_to_binary(Expanded))}\n                        catch\n                            Class:Reason:Stack -\u003e\n                                {error, {Class, Reason, Stack}}\n                        end,\n                        io:format(\"\\x00DREAM_RESULT\\x00\\n\"),\n                        case Result of\n                            {ok, ExpandedAst} -\u003e \n                                io:format(\"ok:~s\\n\", [ExpandedAst]);\n                            {error, Err} -\u003e \n                                io:format(\"err:~p\\n\", [Err])\n                        end,\n                        Loop()\n                end\n        end\n    end,\n    Loop().\n```\n\n### Rust Compiler Integration\n\n```rust\n// src/macros/expander.rs\n\npub struct MacroExpander {\n    beam_process: Child,\n    stdin: ChildStdin,\n    stdout: BufReader\u003cChildStdout\u003e,\n    compiled_macros: HashSet\u003cString\u003e,\n}\n\nimpl MacroExpander {\n    pub fn new() -\u003e Result\u003cSelf, String\u003e {\n        let mut child = Command::new(\"erl\")\n            .args([\"-noshell\", \"-pa\", \"target/macros\"])\n            .arg(\"-eval\")\n            .arg(\"'dream::macro_server':start().\")\n            .stdin(Stdio::piped())\n            .stdout(Stdio::piped())\n            .spawn()?;\n        \n        Ok(Self {\n            stdin: child.stdin.take().unwrap(),\n            stdout: BufReader::new(child.stdout.take().unwrap()),\n            beam_process: child,\n            compiled_macros: HashSet::new(),\n        })\n    }\n    \n    /// Compile a #[macro] function to BEAM\n    pub fn compile_macro(\u0026mut self, macro_def: \u0026MacroDef) -\u003e Result\u003c(), String\u003e {\n        let core = generate_macro_core_erlang(macro_def)?;\n        compile_core_erlang(\u0026core, \"target/macros/dream::macros.beam\")?;\n        self.send_command(\"reload:dream::macros\")?;\n        self.compiled_macros.insert(macro_def.name.clone());\n        Ok(())\n    }\n    \n    /// Expand a macro invocation\n    pub fn expand(\u0026mut self, name: \u0026str, args: Vec\u003cAst\u003e) -\u003e Result\u003cAst, String\u003e {\n        let ast_base64 = base64::encode(\u0026erlang_term::to_binary(\n            \u0026ast_to_erlang_term(\u0026args)\n        ));\n        \n        let result = self.send_command(\u0026format\\!(\"expand:{}:{}\", name, ast_base64))?;\n        \n        let bytes = base64::decode(\u0026result)?;\n        let term = erlang_term::from_binary(\u0026bytes)?;\n        erlang_term_to_ast(\u0026term)\n    }\n    \n    /// Batch expand for better performance\n    pub fn expand_batch(\u0026mut self, calls: Vec\u003c(\u0026str, Vec\u003cAst\u003e)\u003e) -\u003e Result\u003cVec\u003cAst\u003e, String\u003e {\n        let encoded = calls.iter()\n            .map(|(name, args)| {\n                let ast_b64 = base64::encode(\u0026erlang_term::to_binary(\u0026ast_to_erlang_term(args)));\n                format\\!(\"{}:{}\", name, ast_b64)\n            })\n            .collect::\u003cVec\u003c_\u003e\u003e()\n            .join(\"|\");\n        \n        let result = self.send_command(\u0026format\\!(\"batch:{}\", encoded))?;\n        \n        result.split(\"|\")\n            .map(|r| {\n                let bytes = base64::decode(r)?;\n                erlang_term_to_ast(\u0026erlang_term::from_binary(\u0026bytes)?)\n            })\n            .collect()\n    }\n}\n\n/// Convert Rust AST to Erlang term for serialization\nfn ast_to_erlang_term(ast: \u0026Ast) -\u003e ErlangTerm {\n    match ast {\n        Ast::Int { value, span } =\u003e {\n            ErlangTerm::Tuple(vec\\![\n                ErlangTerm::Atom(\"int\".into()),\n                span_to_meta(span),\n                ErlangTerm::Integer(*value),\n            ])\n        }\n        Ast::Binary { op, left, right, span } =\u003e {\n            ErlangTerm::Tuple(vec\\![\n                ErlangTerm::Atom(\"binary\".into()),\n                span_to_meta(span),\n                ErlangTerm::Tuple(vec\\![\n                    binop_to_atom(op),\n                    ast_to_erlang_term(left),\n                    ast_to_erlang_term(right),\n                ]),\n            ])\n        }\n        // ... all other AST variants\n    }\n}\n```\n\n### Compilation Integration\n\n```rust\nimpl Compiler {\n    pub fn compile_module(\u0026mut self, module: \u0026Module) -\u003e Result\u003cCoreErlang, Error\u003e {\n        // Phase 1: Compile macro definitions to BEAM\n        for item in \u0026module.items {\n            if let Item::Function(f) = item {\n                if f.has_attr(\"macro\") {\n                    self.macro_expander.compile_macro(f)?;\n                }\n            }\n        }\n        \n        // Phase 2: Expand all macro invocations\n        let expanded = self.expand_all_macros(\u0026module.items)?;\n        \n        // Phase 3: Type check expanded code\n        self.type_check(\u0026expanded)?;\n        \n        // Phase 4: Generate Core Erlang\n        self.generate_core_erlang(\u0026expanded)\n    }\n    \n    fn expand_all_macros(\u0026mut self, items: \u0026[Item]) -\u003e Result\u003cVec\u003cItem\u003e, Error\u003e {\n        let mut result = Vec::new();\n        \n        for item in items {\n            match item {\n                // #[derive(Debug)] on struct\n                Item::Struct(s) if s.has_attr(\"derive\") =\u003e {\n                    result.push(Item::Struct(s.clone()));\n                    \n                    for derive in s.get_attr(\"derive\").unwrap().args() {\n                        let struct_ast = struct_to_ast(s);\n                        let impl_ast = self.macro_expander.expand(\n                            \u0026format\\!(\"derive_{}\", derive.to_lowercase()),\n                            vec\\![struct_ast],\n                        )?;\n                        result.push(ast_to_item(\u0026impl_ast)?);\n                    }\n                }\n                \n                // Expand macros in function bodies\n                Item::Function(f) =\u003e {\n                    let expanded_body = self.expand_expr_macros(\u0026f.body)?;\n                    result.push(Item::Function(Function {\n                        body: expanded_body,\n                        ..f.clone()\n                    }));\n                }\n                \n                _ =\u003e result.push(item.clone()),\n            }\n        }\n        \n        Ok(result)\n    }\n}\n```\n\n### Full Expansion Example\n\n```rust\n// === Source code ===\n#[macro]\nfn unless(condition: Ast, body: Ast) -\u003e Ast {\n    quote {\n        if \\!unquote(condition) {\n            unquote(body)\n        }\n    }\n}\n\nfn main() {\n    unless x \u003e 10 {\n        io::println(\"small\")\n    }\n}\n\n// === Step 1: Compile macro to BEAM ===\n// Generates dream::macros.beam with unless/2 function\n\n// === Step 2: Encounter unless call, serialize AST ===\n// expand:unless:\u003cbase64 of [\n//   {:binary, #{}, {:\u003e, {:ident, #{}, \"x\"}, {:int, #{}, 10}}},\n//   {:block, #{}, [{:call, ...}]}\n// ]\u003e\n\n// === Step 3: BEAM executes unless/2, returns ===\n// ok:\u003cbase64 of {:if, #{}, \n//   {:unary, #{}, {:\\!, {:binary, ...}}},\n//   {:block, ...},\n//   :none\n// }\u003e\n\n// === Step 4: Deserialize, continue compilation ===\n// if \\!(x \u003e 10) { io::println(\"small\") }\n```\n\n### Performance Considerations\n\n1. **Persistent BEAM process** - Avoid startup cost per expansion\n2. **Batch expansions** - Multiple macros in one round-trip\n3. **Caching** - Cache results for identical AST inputs\n4. **Lazy compilation** - Only compile macros when first used\n\n---\n\n## Design Questions\n\n1. **AST Representation** - Uniform 3-tuple structure (designed above)\n\n2. **Macro Execution Environment** - BEAM shell-out (designed above)\n   - Compile macro to BEAM\n   - Serialize AST as Erlang terms\n   - Execute, return transformed AST\n\n3. **Syntax**\n   - quote/unquote blocks: `quote { ... }`, `unquote(expr)`\n   - Attribute syntax: `#[derive(Debug)]`, `#[route(GET, \"/users\")]`\n\n4. **Hygiene**\n   - Automatic hygiene with `var\\!()` escape hatch (like Elixir)\n   - Track macro expansion context in meta\n\n5. **Use Cases to Support**\n   - Derive implementations (Display, Debug, Serialize)\n   - DSLs (routes, queries, HTML templates)\n   - Control flow (unless, cond, with)\n   - Code generation (GenServer boilerplate)\n   - Testing helpers (assert_match\\!, setup macros)\n\n## Potential Phased Approach\n\nPhase 1: Declarative derive macros\n- #[derive(Debug)] generates impl\n- Pattern-based, compiler built-in\n\nPhase 2: quote/unquote + BEAM shell-out\n- Full AST macro system\n- Macros written in Dream, executed on BEAM\n\nPhase 3: Attribute macros with config\n- #[derive(Serialize, rename_all = \"snake_case\")]\n- Parameterized macro invocation\n\n## References\n- Elixir Macro docs: https://hexdocs.pm/elixir/macros.html\n- Rust macro book: https://danielkeep.github.io/tlborm/book/\n- Rust proc-macro: https://doc.rust-lang.org/reference/procedural-macros.html","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-10T23:10:19.305193-06:00","updated_at":"2026-01-12T20:42:52.508599-06:00","closed_at":"2026-01-12T20:42:52.508599-06:00","close_reason":"Phase 1 (declarative derive macros) implemented. Created toybeam-051 for Phase 2 and toybeam-to2 for Phase 3."}
{"id":"toybeam-3h5","title":"Distributed Erlang","description":"","status":"closed","priority":4,"issue_type":"feature","created_at":"2026-01-02T19:54:02.69802-06:00","updated_at":"2026-01-08T18:25:01.461273-06:00","closed_at":"2026-01-08T18:25:01.461273-06:00","close_reason":"Already works - BEAM runtime handles distribution. Dream .beam files work across nodes via spawn(Node, M, F, A) and message passing."}
{"id":"toybeam-3ly","title":"stdlib/genserver - OTP GenServer","description":"Implement GenServer behavior for Dream. start, start_link, call, cast, reply. Define callbacks: init, handle_call, handle_cast, handle_info, terminate. Critical for OTP patterns.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-03T20:52:42.366985-06:00","updated_at":"2026-01-05T17:51:27.323128-06:00","closed_at":"2026-01-05T17:51:27.323128-06:00","close_reason":"Implemented GenServer stdlib with dynamic dispatch via erlang:apply. Includes start/call/cast/reply/stop functions, server loop with gen_call/gen_cast protocol, and working example."}
{"id":"toybeam-3ru","title":"Add source location tracking in macro errors","description":"","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-14T08:41:52.272841-06:00","updated_at":"2026-01-14T08:56:25.193943-06:00","closed_at":"2026-01-14T08:56:25.193943-06:00","close_reason":"Added span, file, and macro name fields to MacroError for source location tracking (3 tests added)"}
{"id":"toybeam-48a","title":"Generics implementation","description":"Make generic type parameters actually work:\n- Type parameter substitution in structs (e.g., Map\u003cString, int\u003e)\n- Type parameter substitution in enums (e.g., Option\u003cint\u003e)\n- Generic function instantiation\n- Type inference for generic functions\n- Decide on strategy: monomorphization vs type erasure\n\nCurrently generics are syntactic only - they're parsed but have no semantic meaning.","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-03T22:35:09.599787-06:00","updated_at":"2026-01-03T23:41:22.09969-06:00","closed_at":"2026-01-03T23:41:22.09969-06:00","close_reason":"Implemented type unification for generics. Generic function calls, enum variants, and method calls now properly infer type arguments.","dependencies":[{"issue_id":"toybeam-48a","depends_on_id":"toybeam-2s3","type":"blocks","created_at":"2026-01-03T22:35:20.22944-06:00","created_by":"scrogson"}]}
{"id":"toybeam-4by","title":"Fix tree-sitter keyword highlighting word boundaries","description":"","status":"closed","priority":2,"issue_type":"bug","created_at":"2026-01-03T17:50:56.959143-06:00","updated_at":"2026-01-03T17:53:58.610134-06:00","closed_at":"2026-01-03T17:53:58.610134-06:00","close_reason":"Fixed tree-sitter grammar to allow lowercase module names in path expressions"}
{"id":"toybeam-4jn","title":"Binary/bitstring support","description":"Add binary data type for byte manipulation.\n\n## Requirements\n\n- `Value::Binary(Vec\u003cu8\u003e)` - byte array\n- Instructions:\n  - `MakeBinary { bytes, dest }` - create from literal\n  - `BinarySize { bin, dest }` - get byte length\n  - `BinaryAt { bin, index, dest }` - get byte at index\n  - `BinarySlice { bin, start, len, dest }` - extract slice\n  - `BinaryConcat { a, b, dest }` - concatenate binaries\n- Pattern matching on binaries (stretch goal)\n\n## Use Cases\n\n- Network protocols\n- File I/O\n- Serialization","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-02T08:11:21.753707-06:00","updated_at":"2026-01-02T19:37:19.587367-06:00","closed_at":"2026-01-02T19:37:19.587367-06:00","close_reason":"Added Value::Binary with MakeBinary, BinarySize, BinaryAt, BinarySlice, BinaryConcat, IsBinary, StringToBinary, BinaryToString instructions. Added Pattern::Binary for pattern matching. 11 new tests.","labels":["vm"]}
{"id":"toybeam-4zb","title":"stdlib/map - HashMap implementation","description":"Implement Map module for key-value storage. Wrap Erlang maps with idiomatic API: new, get, put, delete, keys, values, merge, has_key, size, to_list, from_list.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-03T20:51:44.192151-06:00","updated_at":"2026-01-03T21:24:47.071462-06:00","closed_at":"2026-01-03T21:24:47.071462-06:00","close_reason":"Implemented stdlib/map module with Map struct, Option-based get(), Result-based fetch(), and core operations. Added Type::Map to parser. Example works with Map::method() syntax."}
{"id":"toybeam-5ak","title":"Implement unquote-splice (#..list) for multiple items","description":"","status":"closed","priority":3,"issue_type":"feature","created_at":"2026-01-14T08:41:46.961698-06:00","updated_at":"2026-01-14T08:53:11.646254-06:00","closed_at":"2026-01-14T08:53:11.646254-06:00","close_reason":"Verified and added tests for unquote-splice (#..list) - feature was already implemented (3 tests added)"}
{"id":"toybeam-5j6","title":"Cross-module struct constructor calls fail","description":"When importing a struct from another module, calling the constructor (e.g., User::new()) generates incorrect module paths like 'http_api::models::user::User' instead of 'dream::http_api::models::user'. Workaround: define structs in same module.","status":"closed","priority":2,"issue_type":"bug","created_at":"2026-01-14T09:07:55.245813-06:00","updated_at":"2026-01-15T20:40:53.761416-06:00","closed_at":"2026-01-15T20:40:53.761416-06:00","close_reason":"Already fixed - http_api example demonstrates working cross-module struct constructor calls (User::new from crate::models::user)"}
{"id":"toybeam-5l3","title":"ETS (Erlang Term Storage)","description":"","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-02T19:54:00.130366-06:00","updated_at":"2026-01-05T21:11:32.026152-06:00","closed_at":"2026-01-05T21:11:32.026152-06:00","close_reason":"Not needed - ETS is accessible directly via :ets::new, :ets::insert, :ets::lookup, etc. Dream compiles to BEAM and can call Erlang modules natively."}
{"id":"toybeam-5ye","title":"REPL connect to running nodes","description":"Allow REPL to connect to a running BEAM node for remote debugging/interaction","status":"open","priority":4,"issue_type":"feature","created_at":"2026-01-11T12:04:24.872071-06:00","updated_at":"2026-01-11T12:04:24.872071-06:00"}
{"id":"toybeam-67g","title":"Add Rust-style Result API methods","description":"Add missing Result methods to match Rust's Result API:\n\nCurrent exports:\n- is_err, is_ok, or, to_list, unwrap, unwrap_err, unwrap_or\n\nMissing Rust methods to add:\n- ok() - Convert Ok(v) to Some(v), Err to None\n- err() - Convert Err(e) to Some(e), Ok to None\n- map(f) - Apply function to Ok value\n- map_err(f) - Apply function to Err value\n- map_or(default, f) - Map Ok with default for Err\n- map_or_else(default_f, f) - Lazy default\n- and_then(f) - Flatmap/bind for Ok\n- or_else(f) - Flatmap/bind for Err\n- unwrap_or_else(f) - Lazy default on unwrap\n- expect(msg) - Unwrap with custom panic message\n- expect_err(msg) - Unwrap err with custom panic message\n- flatten() - Result\u003cResult\u003cT,E\u003e,E\u003e -\u003e Result\u003cT,E\u003e\n- transpose() - Result\u003cOption\u003cT\u003e,E\u003e -\u003e Option\u003cResult\u003cT,E\u003e\u003e\n\nReference: https://doc.rust-lang.org/std/result/enum.Result.html","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-10T22:56:32.570332-06:00","updated_at":"2026-01-11T12:44:10.017966-06:00","closed_at":"2026-01-11T12:44:10.017966-06:00","close_reason":"Added 12 new Result methods: expect, expect_err, unwrap_or_else, ok, err, map, map_err, map_or, map_or_else, and_then, or_else, and. flatten/transpose deferred - needs nested generic parser support (toybeam-dsn)."}
{"id":"toybeam-6p0","title":"Type checking BIFs","description":"Add type checking instructions for guards and runtime checks.\n\n## Requirements\n\nNew instructions that check type and store 1 (true) or 0 (false):\n- `IsInteger { source, dest }`\n- `IsAtom { source, dest }`\n- `IsTuple { source, dest }`\n- `IsList { source, dest }`\n- `IsPid { source, dest }`\n- `IsFunction { source, dest }` (for closures)\n\n## Use Cases\n\n- Guard expressions: `fn foo(x) when is_integer(x) -\u003e ...`\n- Runtime type dispatch\n- Defensive programming","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-02T08:10:51.616443-06:00","updated_at":"2026-01-02T15:17:55.578054-06:00","closed_at":"2026-01-02T15:17:55.578054-06:00","close_reason":"Added 7 type checking instructions: IsInteger, IsAtom, IsTuple, IsList, IsPid, IsFunction, IsString. All return 1 (true) or 0 (false). 8 tests added.","labels":["vm"]}
{"id":"toybeam-6py","title":"Add prelude with Option, Result, etc.","description":"Create a prelude that's automatically imported into every module. Should include: Option (Some, None), Result (Ok, Err). This enables idiomatic Rust-style code without explicit imports.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-03T21:15:11.776406-06:00","updated_at":"2026-01-03T22:32:14.32689-06:00","closed_at":"2026-01-03T22:32:14.32689-06:00","close_reason":"Implemented prelude with Option\u003cT\u003e and Result\u003cT, E\u003e auto-injection into all modules"}
{"id":"toybeam-6q3","title":"Extend unquote to function names in quoted functions","description":"","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-14T08:41:31.042138-06:00","updated_at":"2026-01-14T08:45:30.95544-06:00","closed_at":"2026-01-14T08:45:30.95544-06:00","close_reason":"Implemented unquote in function name position with TDD (2 tests added)"}
{"id":"toybeam-6qv","title":"Function tables and module registry","description":"Add support for named functions and modules to the VM.\n\n## Requirements\n\n- Function table: store named functions with module, name, arity\n- Module registry: lookup module:function/arity at runtime\n- New instructions:\n  - `CallMFA { module, function, arity }` - call a module function\n  - `CallLocal { function, arity }` - call within current module\n- Function references that can be stored in registers\n\n## Design Considerations\n\n- Functions need to be addressable by name, not just instruction index\n- Consider how to handle function clauses (multiple definitions with different patterns)\n- Module loading at VM startup vs dynamic loading","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-02T08:09:50.214978-06:00","updated_at":"2026-01-02T11:16:39.579756-06:00","closed_at":"2026-01-02T11:16:39.579756-06:00","close_reason":"Implemented function tables and module registry with CallMFA, TailCall, MakeFun, Apply, SpawnMFA instructions. 76 tests passing.","labels":["vm"]}
{"id":"toybeam-6tg","title":"Create stdlib/list module","description":"Implement list module with map, filter, fold, reverse, etc. using FFI to erlang:lists","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-03T15:43:33.750303-06:00","updated_at":"2026-01-03T15:54:07.717487-06:00","closed_at":"2026-01-03T15:54:07.717487-06:00","close_reason":"Initial implementation complete - modules compile successfully"}
{"id":"toybeam-77j","title":"stdlib/system - System interaction","description":"Implement System module: env, get_env, put_env, argv, halt, cmd, cwd, tmp_dir, user_home. Return Option/Result where appropriate.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-03T20:52:42.366919-06:00","updated_at":"2026-01-15T23:13:01.659395-06:00","closed_at":"2026-01-15T23:13:01.659395-06:00","close_reason":"Implemented stdlib/system module with env vars, argv, shell commands, directories, system info"}
{"id":"toybeam-7wy","title":"Explicit fully qualified module names","description":"Require explicit module paths like Elixir: mod my_app::users::auth { }. Module name in source = module name at runtime. No implicit prefixing from dream.toml.","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-10T10:17:42.05033-06:00","updated_at":"2026-01-11T12:29:54.808217-06:00","closed_at":"2026-01-11T12:29:54.808217-06:00","close_reason":"Module system already follows Rust conventions: file-based paths, supports both foo.dream and foo/mod.dream styles, package name from config, dream:: prefix added by compiler."}
{"id":"toybeam-8ol","title":"Bit syntax for binaries","description":"","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-02T19:53:59.906983-06:00","updated_at":"2026-01-02T20:28:43.837393-06:00","closed_at":"2026-01-02T20:28:43.837393-06:00","close_reason":"Implemented bit syntax with segment specifiers for binary construction and pattern matching"}
{"id":"toybeam-8os","title":"REPL :type command to show inferred type","description":"Add :type \u003cexpr\u003e command to REPL that shows the inferred type without evaluating","status":"open","priority":3,"issue_type":"feature","created_at":"2026-01-11T12:04:03.650959-06:00","updated_at":"2026-01-11T12:04:03.650959-06:00"}
{"id":"toybeam-92y","title":"Implement method chaining (expr.method() syntax)","description":"Support method chaining like safe_div(10, 2).unwrap_or(0). Currently fails with 'Method calls not yet supported'. This requires resolving methods on expression results, not just struct instances.","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-03T18:36:37.218904-06:00","updated_at":"2026-01-03T19:56:19.833964-06:00","closed_at":"2026-01-03T19:56:19.833964-06:00","close_reason":"Implemented UFCS for method chaining. expr.method(args) is transformed to method(expr, args) where method must be in scope (local or imported)."}
{"id":"toybeam-94d","title":"Compiler: Codegen to bytecode","description":"Generate ToyBEAM bytecode from AST.\n\n## Requirements\n\n- Walk AST and emit instructions\n- Handle:\n  - Function definitions → function table entries\n  - Let bindings → register allocation\n  - Pattern matching → Match instructions\n  - Spawn/send/receive → process instructions\n  - Arithmetic/comparison → binary ops\n  - Control flow → jumps\n\n## Register Allocation\n\n- Simple: stack-based allocation\n- Track live registers, reuse when possible\n- Function args in R0, R1, ...\n- Return value in R0\n\n## Depends On\n\n- Lexer/parser (toybeam-xxx)\n- Function tables in VM (toybeam-6qv)","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-02T08:12:43.904638-06:00","updated_at":"2026-01-02T14:40:28.777216-06:00","closed_at":"2026-01-02T14:40:28.777216-06:00","close_reason":"Implemented codegen module compiling AST to bytecode. Includes expression compilation, control flow, function calls, data structures, process primitives, and pattern matching. Fixed register clobbering across function calls using stack saves.","labels":["compiler"],"dependencies":[{"issue_id":"toybeam-94d","depends_on_id":"toybeam-h5z","type":"blocks","created_at":"2026-01-02T08:13:07.564985-06:00","created_by":"daemon"},{"issue_id":"toybeam-94d","depends_on_id":"toybeam-6qv","type":"blocks","created_at":"2026-01-02T08:13:07.754835-06:00","created_by":"daemon"}]}
{"id":"toybeam-9ir","title":"FFI Result/Option ergonomics","description":"","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-08T18:31:22.431384-06:00","updated_at":"2026-01-09T15:38:02.410291-06:00","closed_at":"2026-01-09T15:38:02.410291-06:00","close_reason":"Implemented Result/Option detection in bindgen: - Parse -type and -spec declarations from Erlang source - Detect {ok,T}|{error,E} → Result\u003cT,E\u003e patterns - Detect T|undefined → Option\u003cT\u003e patterns - Extract parameter names from specs - All stubs regenerated with proper types"}
{"id":"toybeam-9ow","title":"Rename Inspect to Display, add Result/Option formatting","description":"","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-08T19:06:34.831741-06:00","updated_at":"2026-01-08T20:12:52.101715-06:00","closed_at":"2026-01-08T20:12:52.101715-06:00","close_reason":"Renamed Inspect trait to Display, added Result/Option formatting (Ok/Err/Some/None), updated io.dream with dbg/dbg_opts functions"}
{"id":"toybeam-9z3","title":"Tail call optimization","description":"Add proper tail call optimization for recursive functions.\n\n## Requirements\n\n- New instruction: `TailCall { target }` or `TailCallMFA { module, function, arity }`\n- Reuse current stack frame instead of pushing new one\n- Critical for recursive process loops that run indefinitely\n\n## Example\n\n```erlang\nloop(State) -\u003e\n    receive\n        Msg -\u003e loop(handle(Msg, State))  % Must not grow stack\n    end.\n```\n\nWithout TCO, long-running processes would stack overflow.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-02T08:10:20.718196-06:00","updated_at":"2026-01-02T11:16:59.190217-06:00","closed_at":"2026-01-02T11:16:59.190217-06:00","close_reason":"Implemented as part of module system: TailCallMFA and TailCallLocal instructions added in b002669.","labels":["vm"]}
{"id":"toybeam-a04","title":"Design and implement Dream stdlib","description":"Create a standard library for Dream that provides idiomatic wrappers around Erlang/OTP functionality. The stdlib should use the FFI system to call into Erlang modules while providing a Rust-like API.\n\nKey modules to implement:\n- io: Console I/O (println, print, format)\n- list: List operations (map, filter, fold, etc.)\n- string: String manipulation\n- option: Option\u003cT\u003e type (Some/None)\n- result: Result\u003cT, E\u003e type (Ok/Err)\n- process: Process spawning and messaging\n- timer: Timing utilities\n\nDesign principles:\n- Use Rust-like naming conventions\n- Leverage existing Erlang stdlib via FFI\n- Provide type-safe wrappers where possible","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-03T15:42:47.863459-06:00","updated_at":"2026-01-03T20:31:34.095724-06:00","closed_at":"2026-01-03T20:31:34.095724-06:00","close_reason":"Added stdlib/string and stdlib/timer modules. Fixed split to use :all option, removed deprecated 'now' BIF to allow timer::now import.","dependencies":[{"issue_id":"toybeam-a04","depends_on_id":"toybeam-1wx","type":"blocks","created_at":"2026-01-03T15:43:54.403218-06:00","created_by":"scrogson"},{"issue_id":"toybeam-a04","depends_on_id":"toybeam-6tg","type":"blocks","created_at":"2026-01-03T15:43:59.595355-06:00","created_by":"scrogson"},{"issue_id":"toybeam-a04","depends_on_id":"toybeam-xa0","type":"blocks","created_at":"2026-01-03T15:44:04.786067-06:00","created_by":"scrogson"},{"issue_id":"toybeam-a04","depends_on_id":"toybeam-c2a","type":"blocks","created_at":"2026-01-03T15:44:09.962952-06:00","created_by":"scrogson"}]}
{"id":"toybeam-aid","title":"Big integers","description":"","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-02T19:53:49.431765-06:00","updated_at":"2026-01-02T20:08:49.070354-06:00","closed_at":"2026-01-02T20:08:49.070354-06:00","close_reason":"Implemented arbitrary precision integers with automatic overflow promotion"}
{"id":"toybeam-awx","title":"Add binary type support","description":"## Problem\n\nThe examples in `examples/binary.tb` demonstrate binary syntax (`\u003c\u003c...\u003e\u003e`) but all functions return `int` and `0` as placeholders because there's no proper `binary` type in the type system.\n\n## Requirements\n\n1. Add `binary` as a recognized type annotation (e.g., `-\u003e binary`)\n2. Update codegen to handle binary values as first-class return values\n3. Update `examples/binary.tb` to return actual binary values instead of `0`\n\n## Current State\n\n- Parser handles binary construction syntax correctly\n- Parser handles binary pattern matching correctly\n- Type system only has `Named`, `TypeVar`, `Tuple`, `List` variants\n- No way to annotate a function as returning a binary\n\n## Files to modify\n\n- `src/compiler/ast.rs` - possibly add Binary variant to Type enum or recognize \"binary\" as a named type\n- `src/compiler/codegen.rs` - handle binary return values\n- `examples/binary.tb` - update to use proper types and return values","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-02T21:52:40.624077-06:00","updated_at":"2026-01-02T21:58:59.781162-06:00","closed_at":"2026-01-02T21:58:59.781162-06:00","close_reason":"Added Type::Binary variant to AST, parser support for 'binary' keyword as type, and updated examples/binary.tb to use proper return types"}
{"id":"toybeam-b93","title":"REPL BEAM crash recovery","description":"Detect when BEAM process crashes and automatically restart it, preserving bindings if possible","status":"open","priority":3,"issue_type":"feature","created_at":"2026-01-11T12:04:19.56474-06:00","updated_at":"2026-01-11T12:04:19.56474-06:00"}
{"id":"toybeam-ba2","title":"Closures and environment capture","description":"Add closures that capture variables from their environment.\n\n## Requirements\n\n- Closure value type that stores code + captured environment\n- New instructions:\n  - `MakeClosure { code, captures: Vec\u003cRegister\u003e }` - create closure capturing registers\n  - `ApplyClosure { closure, args }` - apply a closure\n- Closures needed for `spawn(|| ...)` syntax in the language\n\n## Design Considerations\n\n- Captured values must be copied (Erlang semantics - no shared mutable state)\n- Closure arity must be tracked\n- Consider: should closures be first-class values passable in messages?","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-02T08:10:20.504413-06:00","updated_at":"2026-01-02T11:53:08.710599-06:00","closed_at":"2026-01-02T11:53:08.710599-06:00","close_reason":"Implemented closures with MakeClosure instruction and extended Apply to handle Value::Closure. 4 new tests added (80 total).","labels":["vm"],"dependencies":[{"issue_id":"toybeam-ba2","depends_on_id":"toybeam-6qv","type":"blocks","created_at":"2026-01-02T08:13:07.941029-06:00","created_by":"daemon"}]}
{"id":"toybeam-bu8","title":"Implement Default derive macro example","description":"","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-14T08:42:02.877313-06:00","updated_at":"2026-01-14T08:57:58.111818-06:00","closed_at":"2026-01-14T08:57:58.111818-06:00","close_reason":"Default derive example covered by simple_derive.dream example"}
{"id":"toybeam-c2a","title":"Create stdlib/result module","description":"Move Result\u003cT, E\u003e enum and helper functions from examples to stdlib","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-03T15:43:44.301158-06:00","updated_at":"2026-01-03T15:54:07.718437-06:00","closed_at":"2026-01-03T15:54:07.718437-06:00","close_reason":"Initial implementation complete - modules compile successfully"}
{"id":"toybeam-c8t","title":"Support associated type bindings in TraitDecl","description":"Currently TraitDecl only stores the trait name. To support Self::State and other associated types in module-level trait implementations, we need to:\n\n1. Add type_bindings to TraitDecl AST node\n2. Update parser to parse: impl genserver::GenServer { type State = int; }\n3. Update type checker to resolve Self::State references using these bindings\n\nExample usage:\n```rust\nmod counter {\n    impl genserver::GenServer {\n        type State = int;\n        type CallMsg = Call;\n    }\n    \n    pub fn handle_call(msg: Self::CallMsg, from: From, state: Self::State) -\u003e ...\n}\n```","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-06T11:42:23.644434-06:00","updated_at":"2026-01-06T13:27:14.567676-06:00","closed_at":"2026-01-06T13:27:14.567676-06:00","close_reason":"Implemented associated type bindings in TraitDecl. Syntax: impl Trait { type State = int; }. Self::State references are resolved by the type checker."}
{"id":"toybeam-cbt","title":"stdlib/enum + Iter trait","description":"Implement Enum module with Iter trait for collection operations: map, filter, reduce, find, any, all, count, take, drop, chunk, zip, flat_map, sort_by, group_by, uniq. Trait allows custom types to be enumerable.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-03T20:52:19.902761-06:00","updated_at":"2026-01-04T00:28:34.868396-06:00","closed_at":"2026-01-04T00:28:34.868396-06:00","close_reason":"Implemented stdlib/enumerable.dream with 40+ collection operations (map, filter, reduce, find, any, all, count, take, drop, chunk, zip, flat_map, sort_by, group_by, uniq, reverse, range, etc.). Also fixed closure variable capture in code generator. The Iter trait for custom enumerable types would require generic trait bounds support - can be a follow-up enhancement."}
{"id":"toybeam-che","title":"List BIFs","description":"Add built-in list operations.\n\n## Requirements\n\n- `ListLength { list, dest }` - O(n) length\n- `ListAppend { a, b, dest }` - concatenate lists (++)\n- `ListReverse { list, dest }` - reverse a list\n- `ListNth { list, n, dest }` - get nth element (0-based)\n- `ListMember { elem, list, dest }` - check membership\n\n## Future Additions\n\n- `ListMap`, `ListFilter`, `ListFold` (or implement in language)\n- `ListSort` with comparator\n- `ListFlatten`","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-02T08:11:37.170302-06:00","updated_at":"2026-01-02T14:54:01.896604-06:00","closed_at":"2026-01-02T14:54:01.896604-06:00","close_reason":"Added ListLength, ListAppend, ListReverse, ListNth, and ListMember instructions with full test coverage.","labels":["vm"]}
{"id":"toybeam-d9y","title":"Restrict module::function syntax to declared modules","description":"Currently `module::function()` works for any Erlang module without requiring an `extern mod` declaration. For example, `erlang::now()` compiles and runs even though there's no `extern mod erlang` in scope.\n\n**Current behavior:**\n- `erlang::now()` compiles and calls Erlang directly (accidental)\n- No validation that the module exists\n\n**Expected behavior:**\n- `module::function()` should only work for:\n  1. Dream modules (with `dream::` prefix or in scope)\n  2. Modules declared with `extern mod module { ... }`\n- Calling an undeclared module should be a compile error\n\n**Workaround:**\nUse explicit extern call syntax: `:erlang::now()`\n\nThis ensures FFI boundaries are explicit and documented via stubs.","status":"open","priority":3,"issue_type":"bug","created_at":"2026-01-11T13:44:11.925896-06:00","updated_at":"2026-01-11T13:44:11.925896-06:00"}
{"id":"toybeam-dow","title":"Extend unquote to return types","description":"","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-14T08:41:41.646634-06:00","updated_at":"2026-01-14T08:51:07.665519-06:00","closed_at":"2026-01-14T08:51:07.665519-06:00","close_reason":"Implemented unquote for return types with TDD (2 tests added)"}
{"id":"toybeam-dsn","title":"Parser: support nested generics (Option\u003cOption\u003cT\u003e\u003e)","description":"The \u003e\u003e token in nested generics like Option\u003cOption\u003cT\u003e\u003e is lexed as a single right-shift operator instead of two closing angle brackets. This prevents flatten() and similar functions that need nested generic types.","status":"closed","priority":2,"issue_type":"bug","created_at":"2026-01-11T12:40:22.358888-06:00","updated_at":"2026-01-11T12:56:31.116461-06:00","closed_at":"2026-01-11T12:56:31.116461-06:00","close_reason":"Parser now splits \u003e\u003e into two \u003e tokens when parsing type arguments. Added Option::flatten and Result::flatten/transpose."}
{"id":"toybeam-dwe","title":"Guards in pattern matching","description":"Add guard expressions to pattern matching.\n\n## Requirements\n\n- Guards are boolean expressions evaluated after pattern match succeeds\n- If guard fails, try next clause\n- Support in both `Match` and `ReceiveMatch` instructions\n\n## Syntax Example (future language)\n\n```rust\nfn abs(n) when n \u003c 0 -\u003e -n;\nfn abs(n) -\u003e n;\n\nreceive {\n    (value, pid) when value \u003e 0 =\u003e send(pid, :positive),\n    (value, pid) =\u003e send(pid, :non_positive)\n}\n```\n\n## Implementation Options\n\n1. Guard as separate instruction sequence with bool result\n2. Guard as expression AST evaluated by VM\n3. Inline guard checks in pattern match instruction","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-02T08:10:51.828003-06:00","updated_at":"2026-01-02T15:29:26.088682-06:00","closed_at":"2026-01-02T15:29:26.088682-06:00","close_reason":"Guards work in match expressions. Fixed register allocation for multiple arms. Added 3 tests. Note: receive guards require VM changes (message can't be consumed before guard passes) - needs follow-up issue.","labels":["vm"],"dependencies":[{"issue_id":"toybeam-dwe","depends_on_id":"toybeam-6p0","type":"blocks","created_at":"2026-01-02T08:13:08.129522-06:00","created_by":"daemon"}]}
{"id":"toybeam-ef4","title":"Macro-generated impl blocks don't resolve methods correctly","description":"","status":"closed","priority":2,"issue_type":"bug","created_at":"2026-01-14T09:41:35.678687-06:00","updated_at":"2026-01-14T10:07:26.925703-06:00","closed_at":"2026-01-14T10:07:26.925703-06:00","close_reason":"Fixed by adding dream:: prefix to resolve_module_name and exporting trait impl methods with simple-name wrappers for dynamic dispatch"}
{"id":"toybeam-ejv","title":"stdlib/uri - URI parsing","description":"Implement URI module: parse (returns Result), to_string, encode, decode, merge, query_params. Struct for URI components.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-03T20:52:42.36687-06:00","updated_at":"2026-01-03T20:52:42.36687-06:00"}
{"id":"toybeam-elo","title":"Timers (send_after, start_timer)","description":"Add timer support for delayed message sending.\n\n## Requirements\n\n- `SendAfter { delay, to, msg, dest }` - send message after delay, store timer ref\n- `StartTimer { delay, dest_reg, msg, timer_dest }` - start timer that sends `{:timeout, ref, msg}`\n- `CancelTimer { timer_ref }` - cancel a pending timer\n- Timer delay in milliseconds (or reductions for deterministic testing)\n\n## Use Cases\n\n- Heartbeat/keepalive patterns\n- Request timeouts\n- Periodic tasks\n- Debouncing\n\n## Implementation\n\n- Scheduler maintains timer heap/queue\n- Timers checked each scheduler step\n- Timer refs for cancellation","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-02T08:11:21.533712-06:00","updated_at":"2026-01-02T19:16:45.014096-06:00","closed_at":"2026-01-02T19:16:45.014096-06:00","close_reason":"Added timer support with SendAfter, StartTimer, CancelTimer, and ReadTimer instructions. Timers are tracked in a queue and fire based on reduction counts for deterministic testing.","labels":["vm"],"dependencies":[{"issue_id":"toybeam-elo","depends_on_id":"toybeam-mje","type":"blocks","created_at":"2026-01-02T08:13:15.40169-06:00","created_by":"daemon"}]}
{"id":"toybeam-f7h","title":"stdlib/code - Code server","description":"Implement Code module for code server interaction: load_file, ensure_loaded, purge, delete, all_loaded, get_path, add_path.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-03T20:52:42.366895-06:00","updated_at":"2026-01-03T20:52:42.366895-06:00"}
{"id":"toybeam-fxj","title":"Union types (T | U) and literal atom types (:ok)","description":"Add union types (T | U syntax) and literal atom types (:ok as a type) to Dream's type system.\n\nThis enables:\n- Functions that return multiple possible types: -\u003e :ok | :error\n- Literal atom types for precise typing: -\u003e :ok\n- Better FFI stubs: io::format can return atom instead of just any\n\nImplementation areas:\n1. Lexer/Parser: Parse | for union types and :atom in type position\n2. AST: Add Type::Union(Vec\u003cType\u003e) and Type::AtomLiteral(String)\n3. Type checker: Add Ty::Union and Ty::AtomLiteral, implement subtyping\n4. Code gen: Handle union types (at runtime, unions are just values)","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-08T17:32:11.491312-06:00","updated_at":"2026-01-08T17:39:32.620168-06:00","closed_at":"2026-01-08T17:39:32.620168-06:00","close_reason":"Implemented union types (T | U) and literal atom types (:ok) in Dream's type system. Features:\n- Parser: parse T | U syntax and :atom in type position\n- AST: Type::Union and Type::AtomLiteral variants\n- Type checker: Ty::Union/AtomLiteral, subtyping rules, union inference for if-else\n- Code gen: handles union types in monomorphization"}
{"id":"toybeam-fz1","title":"Add struct variants to enums","description":"Add support for struct variants in enum definitions, like Rust.\n\n## Current Support\n\n```rust\n// Unit variants - supported\nenum Status { Pending, Complete }\n\n// Tuple variants - supported\nenum Option\u003cT\u003e { Some(T), None }\nenum Result\u003cT, E\u003e { Ok(T), Err(E) }\n```\n\n## Desired: Struct Variants\n\n```rust\nenum Message {\n    Quit,                          // unit\n    Move { x: Int, y: Int },       // struct variant\n    Write(String),                 // tuple\n    ChangeColor { r: Int, g: Int, b: Int },\n}\n\n// Construction\nlet msg = Message::Move { x: 10, y: 20 };\n\n// Pattern matching\nmatch msg {\n    Message::Move { x, y } =\u003e io::println(\"Moving to {x}, {y}\"),\n    Message::ChangeColor { r, .. } =\u003e io::println(\"Red: {r}\"),\n    Message::Quit =\u003e io::println(\"Quit\"),\n    Message::Write(s) =\u003e io::println(s),\n}\n```\n\n## Status\n\n### Completed\n- [x] AST: VariantKind enum (Unit, Tuple, Struct)\n- [x] Parser: struct variant definition syntax\n- [x] Type checker: VariantInfoKind handling\n- [x] Example: examples/types/struct_variants.dream\n- [x] Tests: test_parse_enum_struct_variants\n\n### Remaining\n- [ ] Expr::StructVariant for construction syntax\n- [ ] Pattern::StructVariant for pattern matching\n- [ ] Core Erlang codegen for struct variants (as maps)\n\n## References\n- Rust enum variants: https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-10T23:54:11.136675-06:00","updated_at":"2026-01-11T02:50:01.58108-06:00","closed_at":"2026-01-11T02:50:01.581082-06:00"}
{"id":"toybeam-fzz","title":"Generate .app files for Dream applications","description":"Dream currently compiles to .beam files but doesn't generate .app files. This means Dream apps can't:\n\n1. Be started as OTP applications with application:start/1\n2. Be used as dependencies by other BEAM applications  \n3. Properly participate in the OTP application supervision tree\n\nImplementation:\n- Generate \u003cpackage\u003e.app from dream.toml [application] section\n- Support application callback module (start/2, stop/1)\n- Include module list, version, dependencies in .app file","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-11T17:48:26.151638-06:00","updated_at":"2026-01-11T18:34:47.627018-06:00","closed_at":"2026-01-11T18:34:47.627018-06:00","close_reason":"Implemented .app file generation in cmd_build - generates http_api.app with fully qualified module names (dream::http_api::hello_handler)"}
{"id":"toybeam-ggi","title":"Extend unquote to struct names and field names","description":"","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-14T08:41:36.350898-06:00","updated_at":"2026-01-14T08:48:52.193908-06:00","closed_at":"2026-01-14T08:48:52.193908-06:00","close_reason":"Implemented unquote for struct names and field names with TDD (4 tests added)"}
{"id":"toybeam-gif","title":"Add if let pattern matching syntax","description":"Add Rust-style if let for concise pattern matching. Syntax: if let Some(x) = expr { ... } else { ... }. Useful for Option/Result unwrapping without full match blocks.","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-15T21:32:35.950488-06:00","updated_at":"2026-01-15T22:03:33.591885-06:00","closed_at":"2026-01-15T22:03:33.591885-06:00","close_reason":"Implemented if let pattern matching - desugars to match expression"}
{"id":"toybeam-h5z","title":"Compiler: Lexer and parser","description":"Build lexer and parser for the Rust-like language.\n\n## Requirements\n\n### Lexer\n- Tokenize: keywords, identifiers, literals, operators, punctuation\n- Handle comments (// and /* */)\n- Track source locations for error messages\n\n### Parser\n- Recursive descent or use parser combinator library (nom, pest, lalrpop)\n- Produce AST\n\n### Initial Grammar (subset)\n```\nmodule      = \"mod\" IDENT \"{\" item* \"}\"\nitem        = function | struct | const\nfunction    = \"fn\" IDENT \"(\" params \")\" (\"-\u003e\" type)? block\nparams      = (IDENT \":\" type (\",\" IDENT \":\" type)*)?\nblock       = \"{\" stmt* expr? \"}\"\nstmt        = let_stmt | expr_stmt\nexpr        = match_expr | if_expr | call | binary_op | ...\n```\n\n## Tooling Options\n\n- Hand-written recursive descent (most control)\n- `logos` for lexer + hand-written parser\n- `lalrpop` for full parser generator\n- `pest` for PEG parsing","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-02T08:12:43.679561-06:00","updated_at":"2026-01-02T13:18:25.496384-06:00","closed_at":"2026-01-02T13:18:25.496384-06:00","close_reason":"Implemented lexer and parser with logos. Supports functions, structs, enums, match, if, receive, spawn, send. 17 compiler tests added (97 total).","labels":["compiler"]}
{"id":"toybeam-hqc","title":"Maps data type","description":"Add maps (hash tables) for key-value storage.\n\n## Requirements\n\n- `Value::Map(HashMap\u003cValue, Value\u003e)` - key-value map\n- Instructions:\n  - `MakeMap { pairs, dest }` - create from key-value pairs on stack\n  - `MapGet { map, key, dest }` - get value (crashes if missing)\n  - `MapGetDefault { map, key, default, dest }` - get with default\n  - `MapPut { map, key, value, dest }` - insert/update (returns new map)\n  - `MapRemove { map, key, dest }` - remove key (returns new map)\n  - `MapHas { map, key, dest }` - check if key exists\n  - `MapSize { map, dest }` - get number of entries\n- Pattern matching on maps\n\n## Notes\n\n- Maps are immutable (functional updates return new map)\n- Keys can be any value type\n- Need Eq + Hash for Value (or use BTreeMap with Ord)","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-02T08:11:21.9657-06:00","updated_at":"2026-01-02T18:16:29.492895-06:00","closed_at":"2026-01-02T18:16:29.492895-06:00","close_reason":"Implemented maps: Value::Map type, 10 instructions (MakeMap, MapGet, MapGetDefault, MapPut, MapRemove, MapHas, MapSize, MapKeys, MapValues, IsMap), pattern matching, and full test coverage","labels":["vm"]}
{"id":"toybeam-i2n","title":"REPL errors show internal eval context","description":"When a parse/compile error occurs in the REPL, the error shows the internal eval wrapper context:\n\n```\ndream\u003e erlang::self()\nError: dream::compiler_error\n\n  × expected identifier, found \\`self\\`\n   ╭─[\u003crepl\u003e:3:17]\n 2 │     pub fn __eval__() -\u003e any {\n 3 │         erlang::self()\n   ·                 ──┬─\n   ·                   ╰── here\n 4 │     }\n   ╰────\n```\n\nThe user-facing error should only show their input, not the synthetic module wrapper. Need to adjust line numbers and hide the context of \\`mod dream::__repl__ { pub fn __eval__() -\u003e any { ... } }\\`.","status":"closed","priority":2,"issue_type":"bug","created_at":"2026-01-11T13:14:21.865348-06:00","updated_at":"2026-01-11T13:31:52.725889-06:00","closed_at":"2026-01-11T13:31:52.725889-06:00","close_reason":"Fixed REPL error display to show only user input, not internal eval wrapper. Parse errors now show correct line numbers and source context."}
{"id":"toybeam-i3r","title":"Support top-level expressions in script files","description":"Allow top-level expressions outside of `mod { }` blocks, like Elixir's .exs files.\n\nExample:\n```rust\nmod my_script {\n    pub fn run() -\u003e atom {\n        io::println(\"Running!\");\n        :ok\n    }\n}\n\nmy_script::run()  // Executes when file is loaded\n```\n\nThis enables:\n- Script-style execution without magic `main()` convention\n- More explicit entry points\n- Multiple expressions at top level\n\nChanges needed:\n- Parser: allow expressions outside mod blocks\n- Compiler: emit code to execute top-level expressions\n- Runner: compile and execute","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-10T09:47:02.353569-06:00","updated_at":"2026-01-11T13:22:33.851688-06:00","closed_at":"2026-01-11T13:22:33.851688-06:00","close_reason":"Implemented top-level expressions in script files. Parser now creates a synthetic __script__ module with __main__ function that executes top-level statements/expressions when the script runs."}
{"id":"toybeam-id0","title":"Floats and numeric operations","description":"Add floating-point numbers.\n\n## Requirements\n\n- `Value::Float(f64)` - 64-bit float\n- `LoadFloat { value, dest }` instruction\n- Arithmetic works with mixed int/float (promote to float)\n- Float-specific operations:\n  - `Floor`, `Ceil`, `Round`, `Trunc`\n  - `Sqrt`, `Pow`, `Abs`\n- Comparison across int/float\n\n## Considerations\n\n- NaN handling\n- Float equality in pattern matching (exact vs epsilon)","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-02T08:11:36.958402-06:00","updated_at":"2026-01-02T18:34:23.810652-06:00","closed_at":"2026-01-02T18:34:23.810652-06:00","close_reason":"Implemented floats: Value::Float(f64), LoadFloat, IsFloat, IntToFloat, FloatToInt, Floor, Ceil, Round, Trunc, Sqrt, Abs, Pow instructions. Custom PartialEq/Eq using to_bits() for NaN handling. 8 tests.","labels":["vm"]}
{"id":"toybeam-ill","title":"Process dictionary","description":"Add per-process key-value storage.\n\n## Requirements\n\n- Each process has a local dictionary (HashMap)\n- Instructions:\n  - `PutDict { key, value }` - store value, returns old value or None\n  - `GetDict { key, dest }` - get value or None\n  - `EraseDict { key, dest }` - remove and return value\n  - `GetDictKeys { dest }` - get all keys as list\n\n## Use Cases\n\n- Process-local state without passing through all functions\n- Debugging/tracing context\n- Caching\n\n## Notes\n\n- Controversial in Erlang (hidden state), but useful\n- Dictionary cleared on process exit","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-02T08:11:37.378315-06:00","updated_at":"2026-01-02T18:06:09.029122-06:00","closed_at":"2026-01-02T18:06:09.029122-06:00","close_reason":"Implemented process dictionary: PutDict, GetDict, EraseDict, GetDictKeys instructions with full test coverage","labels":["vm"]}
{"id":"toybeam-im3","title":"Support 'as' alias on use declarations","description":"Add support for renaming imports with `as`, like Rust:\n\n```dream\nuse std::collections::HashMap as Map;\nuse io::println as print;\nuse some_long_module::some_function as func;\n```\n\nThis enables:\n- Avoiding name conflicts\n- Shorter aliases for long names\n- Clearer code when import names are ambiguous\n\nParser changes needed:\n- Extend `parse_use_decl` to handle optional `as \u003cident\u003e` suffix\n\nType checker/codegen changes:\n- Track alias in scope instead of original name\n- Resolve alias to original path when generating calls","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-11T13:53:03.720402-06:00","updated_at":"2026-01-11T13:58:23.854706-06:00","closed_at":"2026-01-11T13:58:23.854706-06:00","close_reason":"Feature already implemented. Parser, type checker, and code generator all support 'as' aliases for use declarations. Works for both single imports (use foo::bar as baz;) and group imports (use foo::{a as x, b as y};)."}
{"id":"toybeam-j10","title":"stdlib/datetime - Date and time","description":"Implement DateTime module with timezone support. now, utc_now, from_unix, to_unix, add, diff, format, parse. Consider generic over timezone. Use calendar module.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-03T20:52:42.366414-06:00","updated_at":"2026-01-03T20:52:42.366414-06:00"}
{"id":"toybeam-jsv","title":"Add Erlang record support","description":"## Summary\n\nDream currently lacks support for Erlang records. When interacting with Erlang/OTP libraries like Cowboy, we have to type record parameters as `any`, losing type safety.\n\n## Current Problem\n\n```dream\n// Cowboy request is actually #cowboy_req{} record, but we use `any`\npub fn init(req: any, state: any) -\u003e (atom, any, any) {\n    // No type checking on req fields\n    let method = cowboy_req::method(req);\n    // ...\n}\n```\n\n## Proposed Solution\n\nAdd a `#[record]` attribute or similar syntax to define Dream types that map to Erlang records:\n\n```dream\n// Option 1: Attribute on struct\n#[record = \"cowboy_req\"]\npub struct CowboyReq {\n    method: Binary,\n    path: Binary,\n    headers: [(Binary, Binary)],\n    qs: Binary,\n    // ...\n}\n\n// Option 2: Dedicated record keyword\npub record CowboyReq {\n    method: Binary,\n    path: Binary,\n    // ...\n}\n```\n\nThen use with proper typing:\n\n```dream\npub fn init(req: CowboyReq, state: any) -\u003e (atom, CowboyReq, any) {\n    let method = req.method;  // Type-checked field access\n    // ...\n}\n```\n\n## Implementation Considerations\n\nErlang records are compile-time constructs that expand to tagged tuples:\n- `#cowboy_req{method = M}` becomes `{cowboy_req, M, ...}`\n- Field access `Req#cowboy_req.method` becomes `element(2, Req)`\n- Record info is in `.hrl` header files\n\nOptions for implementation:\n1. **Parse .hrl files** - Extract record definitions from Erlang headers\n2. **Manual declaration** - Require explicit field definitions in Dream\n3. **Bindgen enhancement** - Generate record types from Erlang source\n\nField access compilation:\n- `req.method` -\u003e `element(N, Req)` where N is field position + 1\n- Or use Erlang's record syntax in generated code (requires record definition)\n\n## Use Cases\n\n- Cowboy request/response handling (`#cowboy_req{}`)\n- ETS table entries (often records)\n- OTP behaviors (gen_server state often uses records)\n- Any Erlang library using records in its API","status":"open","priority":2,"issue_type":"feature","created_at":"2026-01-16T19:13:51.983919-06:00","updated_at":"2026-01-16T19:13:51.983919-06:00"}
{"id":"toybeam-l4j","title":"Multi-clause functions (pattern matching on params)","description":"Support Erlang-style multi-clause function definitions where multiple functions\nwith the same name can have different patterns or arities.\n\nExample:\n```rust\npub fn factorial(0) -\u003e int { 1 }\npub fn factorial(n: int) -\u003e int { n * factorial(n - 1) }\n\npub fn greet() -\u003e string { \"Hello!\" }\npub fn greet(name: string) -\u003e string { \"Hello, \" ++ name }\n```\n\nRequires:\n1. Parser: Allow multiple fn definitions with same name, pattern params\n2. AST: Store function clauses together\n3. Type checker: Validate clauses have consistent return types\n4. Codegen: Emit Erlang multi-clause functions","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-04T16:26:16.32755-06:00","updated_at":"2026-01-04T16:53:41.603566-06:00","closed_at":"2026-01-04T16:53:41.603566-06:00","close_reason":"Implemented multi-clause functions with pattern matching on parameters. Parser supports optional type annotation for literals, codegen groups functions by (name, arity) and emits case-based dispatch."}
{"id":"toybeam-lau","title":"Add method resolution pass for stdlib methods","description":"After type checking, walk the AST and resolve MethodCalls based on receiver type. For primitives (string, list), map to corresponding stdlib module (string, enumerable). Store resolution info for codegen to use.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-04T09:49:01.386821-06:00","updated_at":"2026-01-04T10:29:24.998745-06:00","closed_at":"2026-01-04T10:29:24.998745-06:00","close_reason":"Implemented type-directed method resolution. Added resolved_module field to MethodCall AST, resolution pass in typeck.rs, and codegen support. s.trim().to_upper() now resolves to string::trim and string::to_upper without imports.","dependencies":[{"issue_id":"toybeam-lau","depends_on_id":"toybeam-2of","type":"blocks","created_at":"2026-01-04T09:49:22.229114-06:00","created_by":"scrogson"}]}
{"id":"toybeam-lp3","title":"try/catch/after error handling","description":"Add structured error handling.\n\n## Requirements\n\n- `Try { catch_target, after_target }` - begin try block\n- `EndTry` - successful completion of try block\n- `Throw { class, reason }` - throw an exception\n  - Classes: `:error`, `:exit`, `:throw`\n- Catch block receives `{class, reason, stacktrace}`\n- After block always runs (cleanup)\n\n## Semantics\n\n```rust\ntry {\n    risky_operation()\n} catch {\n    (:error, reason) =\u003e handle_error(reason),\n    (:exit, reason) =\u003e handle_exit(reason)\n} after {\n    cleanup()\n}\n```\n\n## Implementation\n\n- Exception stack in process state\n- Unwind to nearest catch on throw\n- After blocks must run even on exception","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-02T08:11:50.54581-06:00","updated_at":"2026-01-02T19:29:36.897356-06:00","closed_at":"2026-01-02T19:29:36.897356-06:00","close_reason":"Added try/catch/after with Try, EndTry, Throw, GetException, ClearException, Reraise instructions. Exception stack tracks handlers for unwinding. 6 new tests.","labels":["vm"]}
{"id":"toybeam-lu9","title":"Add Rust-style Option API methods","description":"Add missing Option methods to match Rust's Option API:\n\nCurrent exports:\n- is_none, is_some, or, to_list, unwrap, unwrap_or\n\nMissing Rust methods to add:\n- ok_or(err) - Convert Some(v) to Ok(v), None to Err(err)\n- ok_or_else(f) - Like ok_or but lazily evaluates error\n- map(f) - Apply function to inner value if Some\n- map_or(default, f) - Map with default for None\n- map_or_else(default_f, f) - Lazy default\n- and_then(f) - Flatmap/bind\n- filter(predicate) - Convert to None if predicate fails\n- flatten() - Option\u003cOption\u003cT\u003e\u003e -\u003e Option\u003cT\u003e\n- zip(other) - Combine two Options into Option of tuple\n- unzip() - Split Option of tuple into tuple of Options\n- expect(msg) - Unwrap with custom panic message\n- take() - For mutable contexts\n- replace(value) - For mutable contexts\n\nReference: https://doc.rust-lang.org/std/option/enum.Option.html","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-10T22:56:20.239135-06:00","updated_at":"2026-01-11T12:40:10.837963-06:00","closed_at":"2026-01-11T12:40:10.837963-06:00","close_reason":"Added 14 new Option methods: expect, unwrap_or_else, map, map_or, map_or_else, and_then, and, filter, or_else, xor, zip, zip_with, ok_or, ok_or_else. flatten() deferred - needs nested generic parser support."}
{"id":"toybeam-mje","title":"References (make_ref)","description":"Add unique reference values for request/response correlation.\n\n## Requirements\n\n- `Value::Ref(u64)` - globally unique reference\n- `MakeRef { dest }` instruction - creates new unique ref\n- Refs are comparable for equality only\n- Used for call/response patterns:\n\n```rust\nlet ref = make_ref();\nsend(server, (ref, :get_data));\nreceive {\n    (^ref, data) =\u003e data  // Match only our response\n}\n```\n\n## Implementation\n\n- Scheduler maintains global ref counter\n- Each ref is unique across all processes","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-02T08:10:52.035315-06:00","updated_at":"2026-01-02T18:25:44.826107-06:00","closed_at":"2026-01-02T18:25:44.826107-06:00","close_reason":"Implemented references: Value::Ref(u64), MakeRef and IsRef instructions, global ref counter in Scheduler, 5 tests covering uniqueness and usage as map keys","labels":["vm"]}
{"id":"toybeam-muk","title":"Exit reasons and trap_exit","description":"Add proper exit signals with reasons and trap_exit flag.\n\n## Requirements\n\n### Exit Reasons\n- Processes exit with a reason (not just crash/normal)\n- `Exit { reason: Value }` instruction\n- Exit reasons propagate through links\n- Normal exit = `:normal` atom\n\n### trap_exit Flag\n- Process flag to convert exit signals to messages\n- When trap_exit=true, linked process crash sends `{:EXIT, Pid, Reason}` message\n- `SetFlag { flag, value }` instruction\n- `TrapExit` flag enum\n\n### Link Behavior\n- Normal exit: no signal to linked processes (unless trap_exit)\n- Abnormal exit: signal all linked processes\n- trap_exit converts signals to mailbox messages","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-02T08:10:20.925012-06:00","updated_at":"2026-01-02T18:51:04.900192-06:00","closed_at":"2026-01-02T18:51:04.900192-06:00","close_reason":"Added Exit instruction with custom reasons, TrapExit instruction for converting exit signals to messages, and updated SystemMsg to use Value for exit reasons. Normal exits don't propagate to linked processes, abnormal exits do (unless trap_exit is enabled).","labels":["vm"]}
{"id":"toybeam-n4c","title":"Default trait implementations","description":"","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-08T18:31:11.606612-06:00","updated_at":"2026-01-09T08:57:51.392908-06:00","closed_at":"2026-01-09T08:57:51.392908-06:00","close_reason":"Added validation for trait implementations - ensures required methods are implemented and associated types are bound"}
{"id":"toybeam-n4s","title":"? operator: function-level error propagation","description":"Wrap Result-returning functions in try/catch to properly propagate errors from ? operator instead of just throwing","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-08T18:57:09.494488-06:00","updated_at":"2026-01-09T19:02:55.292229-06:00","closed_at":"2026-01-09T19:02:55.292229-06:00","close_reason":"Implemented ? operator error propagation. Functions returning Result\u003cT,E\u003e or Option\u003cT\u003e now wrap their body in try/catch to convert thrown errors back to proper return values. Fixed Core Erlang syntax (try expressions don't have closing 'end' keyword)."}
{"id":"toybeam-nxb","title":"Networking (TCP/UDP)","description":"","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-02T19:54:00.342126-06:00","updated_at":"2026-01-05T21:14:47.723803-06:00","closed_at":"2026-01-05T21:14:47.723803-06:00","close_reason":"Not needed - :gen_tcp, :gen_udp, :ssl available directly. Can add Dream wrappers later if ergonomics warrant it."}
{"id":"toybeam-o61","title":"Add snapshot testing with insta","description":"","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-09T09:26:36.262609-06:00","updated_at":"2026-01-09T09:39:02.680688-06:00","closed_at":"2026-01-09T09:39:02.680688-06:00","close_reason":"Added insta snapshot testing for compile errors and valid code"}
{"id":"toybeam-o8v","title":"Dependency management (hex.pm and git)","description":"Add dependency management to Dream projects, supporting:\n\n**Sources:**\n- hex.pm packages (Elixir/Erlang ecosystem)\n- Git repositories\n- Local paths\n\n**dream.toml syntax:**\n```toml\n[dependencies]\njason = \"1.4\"                           # hex.pm\ncowboy = { version = \"2.10\", hex = true }\nmy_lib = { git = \"https://github.com/user/my_lib\" }\nlocal_dep = { path = \"../my_local_lib\" }\n```\n\n**Implementation options:**\n\n1. **Shell out to mix/rebar3** (simplest)\n   - Generate mix.exs or rebar.config from dream.toml\n   - Run `mix deps.get` or `rebar3 get-deps`\n   - Add compiled .beam paths to code path\n   - Pros: Leverages existing tooling, full hex.pm compatibility\n   - Cons: Requires Elixir/rebar3 installed\n\n2. **Native hex client** (more work, standalone)\n   - Implement hex API client in Rust\n   - Download and extract packages directly\n   - Compile Erlang sources ourselves (or use precompiled)\n   - Pros: No external dependencies\n   - Cons: Significant implementation effort\n\n3. **Hybrid approach**\n   - Use mix for Elixir deps, erlc for Erlang deps\n   - Native git clone for git deps\n   - Cache in _build or deps/ directory\n\n**Commands needed:**\n- `dream deps get` - fetch dependencies\n- `dream deps update` - update to latest compatible versions\n- `dream deps list` - show dependency tree\n\n**Considerations:**\n- Lock file (dream.lock) for reproducible builds\n- Elixir deps need Elixir compiler (mix)\n- Pure Erlang deps can use erlc directly\n- Version resolution (semantic versioning)","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-11T14:12:49.038467-06:00","updated_at":"2026-01-11T15:07:36.397485-06:00","closed_at":"2026-01-11T15:07:36.397485-06:00","close_reason":"Implemented hex.pm and git dependency support with async downloads"}
{"id":"toybeam-oct","title":"Document macro authoring","description":"","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-14T08:42:08.198556-06:00","updated_at":"2026-01-14T08:58:45.746298-06:00","closed_at":"2026-01-14T08:58:45.746298-06:00","close_reason":"Macro authoring documented via example files (examples/macros/) and rustdoc in macro_expander.rs"}
{"id":"toybeam-pc9","title":"Ports for external programs","description":"","status":"open","priority":3,"issue_type":"feature","created_at":"2026-01-02T19:54:00.564199-06:00","updated_at":"2026-01-02T19:54:00.564199-06:00"}
{"id":"toybeam-pik","title":"Add multi-file support to dream run for standalone files","description":"","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-03T17:50:51.675862-06:00","updated_at":"2026-01-03T18:55:26.45216-06:00","closed_at":"2026-01-03T18:55:26.45216-06:00","close_reason":"Implemented multi-file project support. Added load_all_in_dir() to ModuleLoader for recursive file discovery, updated cmd_build to compile all .dream files in src/, and created multifile_project example."}
{"id":"toybeam-pio","title":"System info primitives","description":"","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-02T19:53:41.366369-06:00","updated_at":"2026-01-02T19:57:28.090008-06:00","closed_at":"2026-01-02T19:57:28.090008-06:00","close_reason":"Added SelfPid, ProcessList, ProcessCount, IsAlive, ProcessInfo, ModuleList, FunctionExported instructions. 7 tests."}
{"id":"toybeam-ptk","title":"stdlib/stream - Lazy evaluation","description":"Implement Stream module for lazy/infinite sequences. Functions return streams that evaluate on demand: iterate, cycle, repeatedly, unfold, take, map, filter, chunk. Composable with Enum.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-03T20:52:19.902749-06:00","updated_at":"2026-01-05T21:37:13.054907-06:00","closed_at":"2026-01-05T21:37:13.054907-06:00","close_reason":"Implemented Stream module with lazy evaluation. Creation: iterate, repeatedly, cycle, unfold, from_list, from, range, duplicate. Transformations: map, filter, take, drop, take_while, drop_while, zip, concat, flat_map. Consumption: to_list, fold, run, each, first, count, sum, any, all."}
{"id":"toybeam-qaw","title":"? operator for Result/Option","description":"","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-08T18:31:06.223103-06:00","updated_at":"2026-01-08T18:57:04.158598-06:00","closed_at":"2026-01-08T18:57:04.158598-06:00","close_reason":"Basic ? operator implemented. Extracts values from Ok/Some. Throws on Err/None. Full propagation requires function-level try/catch (future work)."}
{"id":"toybeam-qoc","title":"IO primitives","description":"","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-02T19:53:37.394249-06:00","updated_at":"2026-01-02T19:57:27.885524-06:00","closed_at":"2026-01-02T19:57:27.885524-06:00","close_reason":"Added PrintLn, ReadLine, FileRead, FileWrite, FileExists, FileDelete instructions. 3 tests."}
{"id":"toybeam-qxx","title":"UFCS should resolve impl methods","description":"Method calls like m.put() use UFCS but only check imports, not impl_methods. Should allow m.put() to call Map_put when m has __struct__ = Map. Requires runtime dispatch or type tracking.","status":"closed","priority":2,"issue_type":"bug","created_at":"2026-01-03T21:24:23.434295-06:00","updated_at":"2026-01-03T23:55:22.23529-06:00","closed_at":"2026-01-03T23:55:22.23529-06:00","close_reason":"UFCS now dispatches to impl methods at runtime via __struct__ tag matching"}
{"id":"toybeam-sga","title":"Cross-module generic function calls without turbofish","description":"## Problem\n\nWhen calling a generic function from another module without explicit type args (turbofish), the call fails at runtime.\n\n`io::dbg::\u003cint\u003e(42)` works, but `io::dbg(42)` fails with undef error.\n\n## Root Cause\n\nType checker infers types but doesn't write them back to the AST. Code generator sees empty type_args and emits non-generic call.\n\n## Impact\n\nGeneric stdlib functions can't be called without turbofish. Workaround: use `any` instead of generics.","status":"closed","priority":1,"issue_type":"bug","created_at":"2026-01-08T22:12:22.930294-06:00","updated_at":"2026-01-08T23:05:57.877025-06:00","closed_at":"2026-01-08T23:05:57.877025-06:00","close_reason":"Implemented inferred_type_args field in AST, TypeChecker annotates after unification, Codegen uses effective_type_args for monomorphization. io::dbg(42) now works without turbofish."}
{"id":"toybeam-sq4","title":"Add .dreamt type declaration files for FFI","description":"Add type stub files (.dreamt) for declaring types of external Erlang/Elixir/Gleam libraries.\n\n## Goals\n- Enable type checking for FFI calls to third-party libraries\n- Support manual stub creation and auto-generation from specs\n\n## Design\n\n### File format (.dreamt)\n```rust\nextern mod phoenix {\n    mod socket {\n        fn connect(params: Map\u003cstring, any\u003e) -\u003e Socket;\n        fn channel(socket: Socket, topic: string) -\u003e Channel;\n    }\n}\n```\n\n### Implementation Steps\n1. [ ] Add .dreamt parser (subset of Dream syntax with `extern mod`)\n2. [ ] Load stubs during type checking\n3. [ ] Resolve FFI calls against stub declarations\n4. [ ] Add `dream types gen --from-erlang` for Erlang -spec parsing\n5. [ ] Add types/ directory support in project structure\n\n### Distribution\n- types/ directory in projects for local stubs\n- Stubs can ship with packages\n- Future: community stub registry","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-08T13:52:45.96666-06:00","updated_at":"2026-01-08T14:28:54.064395-06:00","closed_at":"2026-01-08T14:28:54.064395-06:00","close_reason":"Implemented .dreamt stub files with extern mod declarations, parser support, type checker integration, and erlang stdlib stubs"}
{"id":"toybeam-tdn","title":"REPL :core command to show Core Erlang output","description":"Add :core \u003cexpr\u003e command to REPL that shows the generated Core Erlang code for debugging","status":"open","priority":3,"issue_type":"feature","created_at":"2026-01-11T12:04:08.948431-06:00","updated_at":"2026-01-11T12:04:08.948431-06:00"}
{"id":"toybeam-tj5","title":"Generic type alias substitution","description":"","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-08T18:31:17.022337-06:00","updated_at":"2026-01-09T09:28:03.171522-06:00","closed_at":"2026-01-09T09:28:03.171522-06:00","close_reason":"Added TypeAliasInfo to preserve type params; updated ast_type_to_ty to substitute type args"}
{"id":"toybeam-to2","title":"Implement parameterized attribute macros (Phase 3)","description":"Phase 3 of the macro system: support parameterized attribute macros.\n\nDepends on Phase 2 (quote/unquote + BEAM shell-out)\n\nExamples:\n- #[derive(Serialize, rename_all = \"snake_case\")]\n- #[route(GET, \"/users\")]\n- Parameterized macro invocation","status":"open","priority":3,"issue_type":"feature","created_at":"2026-01-12T20:42:35.104793-06:00","updated_at":"2026-01-12T20:42:35.104793-06:00","dependencies":[{"issue_id":"toybeam-to2","depends_on_id":"toybeam-051","type":"blocks","created_at":"2026-01-12T20:42:47.236208-06:00","created_by":"scrogson"}]}
{"id":"toybeam-tpr","title":"stdlib/file - File I/O","description":"Implement File module: read, write, read_lines, write_lines, exists, mkdir, rm, cp, mv, ls, stat, cwd, cd. Wrap Erlang file module.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-03T20:52:19.902765-06:00","updated_at":"2026-01-05T21:26:22.075149-06:00","closed_at":"2026-01-05T21:26:22.075149-06:00","close_reason":"Implemented Elixir-style File module with read/write/append, exists/dir/regular/stat/size, mkdir/mkdir_p/rmdir/ls, cp/rename/rm/rm_rf, cwd/cd, chmod, ln/ln_s/read_link, touch, open/close. All functions take path as first arg for pipe compatibility."}
{"id":"toybeam-w48","title":"Macro AST construction hits type checker limitations","description":"When building AST tuples manually in macros (e.g., for derive macros), the type checker fails with 'list elements must have the same type' when constructing heterogeneous AST tuples like [(:atom, x), (:field_access, y, z), acc]. Need to support any-typed AST construction.","status":"closed","priority":3,"issue_type":"bug","created_at":"2026-01-14T09:08:08.305141-06:00","updated_at":"2026-01-14T09:21:27.950159-06:00","closed_at":"2026-01-14T09:21:27.950159-06:00","close_reason":"Fixed type checker to widen heterogeneous list elements to 'any' instead of erroring"}
{"id":"toybeam-wqi","title":"Codegen uses resolved stdlib methods","description":"Update codegen to check if a MethodCall has been resolved to a stdlib module. If so, emit call to that module instead of local function call.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-04T09:49:12.439068-06:00","updated_at":"2026-01-04T10:29:24.999249-06:00","closed_at":"2026-01-04T10:29:24.999249-06:00","close_reason":"Implemented type-directed method resolution. Added resolved_module field to MethodCall AST, resolution pass in typeck.rs, and codegen support. s.trim().to_upper() now resolves to string::trim and string::to_upper without imports.","dependencies":[{"issue_id":"toybeam-wqi","depends_on_id":"toybeam-lau","type":"blocks","created_at":"2026-01-04T09:49:27.448458-06:00","created_by":"scrogson"}]}
{"id":"toybeam-xa0","title":"Create stdlib/option module","description":"Move Option\u003cT\u003e enum and helper functions from examples to stdlib","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-03T15:43:39.021389-06:00","updated_at":"2026-01-03T15:54:07.717991-06:00","closed_at":"2026-01-03T15:54:07.717991-06:00","close_reason":"Initial implementation complete - modules compile successfully"}
{"id":"toybeam-y4p","title":"Implement Debug derive macro example","description":"","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-14T08:41:57.574714-06:00","updated_at":"2026-01-14T08:57:52.937694-06:00","closed_at":"2026-01-14T08:57:52.937694-06:00","close_reason":"Created example macro files demonstrating Debug derive implementation"}
{"id":"toybeam-z7b","title":"stdlib/supervisor - OTP Supervisor","description":"Implement Supervisor behavior. start_link, child_spec, which_children, count_children. Supervision strategies: one_for_one, one_for_all, rest_for_one.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-03T20:52:42.367036-06:00","updated_at":"2026-01-05T21:03:14.165526-06:00","closed_at":"2026-01-05T21:03:14.165526-06:00","close_reason":"Implemented OTP-style Supervisor with start_link/start, supervision strategies (one_for_one, one_for_all, rest_for_one), child management (which_children, count_children, start_child, terminate_child), and automatic restart on crash. Also added support for quoted atoms in patterns (:'EXIT')."}
{"id":"toybeam-zt6","title":"Hot code loading","description":"","status":"closed","priority":4,"issue_type":"feature","created_at":"2026-01-02T19:54:01.00302-06:00","updated_at":"2026-01-08T18:24:49.20144-06:00","closed_at":"2026-01-08T18:24:49.20144-06:00","close_reason":"Already works - BEAM runtime handles hot code loading. Dream compiles to .beam files which can be reloaded via code:load_file/1 or code:purge/load."}
