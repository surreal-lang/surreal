{"id":"toybeam-0bi","title":"Unlink and demonitor","description":"Add ability to remove links and monitors.\n\n## Requirements\n\n- `Unlink { target }` - remove bidirectional link\n- `Demonitor { ref }` - cancel a monitor by its reference\n- Monitor instruction should return a reference for later cancellation\n\n## Changes Needed\n\n- `Monitor` instruction needs to store monitor ref in dest register\n- Track monitors by ref, not just by target pid\n- `Value::MonitorRef(u64)` or reuse `Value::Ref`","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-02T08:11:50.331397-06:00","updated_at":"2026-01-02T08:11:50.331397-06:00","labels":["vm"],"dependencies":[{"issue_id":"toybeam-0bi","depends_on_id":"toybeam-mje","type":"blocks","created_at":"2026-01-02T08:13:15.208106-06:00","created_by":"daemon"}]}
{"id":"toybeam-4jn","title":"Binary/bitstring support","description":"Add binary data type for byte manipulation.\n\n## Requirements\n\n- `Value::Binary(Vec\u003cu8\u003e)` - byte array\n- Instructions:\n  - `MakeBinary { bytes, dest }` - create from literal\n  - `BinarySize { bin, dest }` - get byte length\n  - `BinaryAt { bin, index, dest }` - get byte at index\n  - `BinarySlice { bin, start, len, dest }` - extract slice\n  - `BinaryConcat { a, b, dest }` - concatenate binaries\n- Pattern matching on binaries (stretch goal)\n\n## Use Cases\n\n- Network protocols\n- File I/O\n- Serialization","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-02T08:11:21.753707-06:00","updated_at":"2026-01-02T08:11:21.753707-06:00","labels":["vm"]}
{"id":"toybeam-6p0","title":"Type checking BIFs","description":"Add type checking instructions for guards and runtime checks.\n\n## Requirements\n\nNew instructions that check type and store 1 (true) or 0 (false):\n- `IsInteger { source, dest }`\n- `IsAtom { source, dest }`\n- `IsTuple { source, dest }`\n- `IsList { source, dest }`\n- `IsPid { source, dest }`\n- `IsFunction { source, dest }` (for closures)\n\n## Use Cases\n\n- Guard expressions: `fn foo(x) when is_integer(x) -\u003e ...`\n- Runtime type dispatch\n- Defensive programming","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-02T08:10:51.616443-06:00","updated_at":"2026-01-02T08:10:51.616443-06:00","labels":["vm"]}
{"id":"toybeam-6qv","title":"Function tables and module registry","description":"Add support for named functions and modules to the VM.\n\n## Requirements\n\n- Function table: store named functions with module, name, arity\n- Module registry: lookup module:function/arity at runtime\n- New instructions:\n  - `CallMFA { module, function, arity }` - call a module function\n  - `CallLocal { function, arity }` - call within current module\n- Function references that can be stored in registers\n\n## Design Considerations\n\n- Functions need to be addressable by name, not just instruction index\n- Consider how to handle function clauses (multiple definitions with different patterns)\n- Module loading at VM startup vs dynamic loading","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-02T08:09:50.214978-06:00","updated_at":"2026-01-02T11:16:39.579756-06:00","closed_at":"2026-01-02T11:16:39.579756-06:00","close_reason":"Implemented function tables and module registry with CallMFA, TailCall, MakeFun, Apply, SpawnMFA instructions. 76 tests passing.","labels":["vm"]}
{"id":"toybeam-94d","title":"Compiler: Codegen to bytecode","description":"Generate ToyBEAM bytecode from AST.\n\n## Requirements\n\n- Walk AST and emit instructions\n- Handle:\n  - Function definitions → function table entries\n  - Let bindings → register allocation\n  - Pattern matching → Match instructions\n  - Spawn/send/receive → process instructions\n  - Arithmetic/comparison → binary ops\n  - Control flow → jumps\n\n## Register Allocation\n\n- Simple: stack-based allocation\n- Track live registers, reuse when possible\n- Function args in R0, R1, ...\n- Return value in R0\n\n## Depends On\n\n- Lexer/parser (toybeam-xxx)\n- Function tables in VM (toybeam-6qv)","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-02T08:12:43.904638-06:00","updated_at":"2026-01-02T14:40:28.777216-06:00","closed_at":"2026-01-02T14:40:28.777216-06:00","close_reason":"Implemented codegen module compiling AST to bytecode. Includes expression compilation, control flow, function calls, data structures, process primitives, and pattern matching. Fixed register clobbering across function calls using stack saves.","labels":["compiler"],"dependencies":[{"issue_id":"toybeam-94d","depends_on_id":"toybeam-h5z","type":"blocks","created_at":"2026-01-02T08:13:07.564985-06:00","created_by":"daemon"},{"issue_id":"toybeam-94d","depends_on_id":"toybeam-6qv","type":"blocks","created_at":"2026-01-02T08:13:07.754835-06:00","created_by":"daemon"}]}
{"id":"toybeam-9z3","title":"Tail call optimization","description":"Add proper tail call optimization for recursive functions.\n\n## Requirements\n\n- New instruction: `TailCall { target }` or `TailCallMFA { module, function, arity }`\n- Reuse current stack frame instead of pushing new one\n- Critical for recursive process loops that run indefinitely\n\n## Example\n\n```erlang\nloop(State) -\u003e\n    receive\n        Msg -\u003e loop(handle(Msg, State))  % Must not grow stack\n    end.\n```\n\nWithout TCO, long-running processes would stack overflow.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-02T08:10:20.718196-06:00","updated_at":"2026-01-02T11:16:59.190217-06:00","closed_at":"2026-01-02T11:16:59.190217-06:00","close_reason":"Implemented as part of module system: TailCallMFA and TailCallLocal instructions added in b002669.","labels":["vm"]}
{"id":"toybeam-ba2","title":"Closures and environment capture","description":"Add closures that capture variables from their environment.\n\n## Requirements\n\n- Closure value type that stores code + captured environment\n- New instructions:\n  - `MakeClosure { code, captures: Vec\u003cRegister\u003e }` - create closure capturing registers\n  - `ApplyClosure { closure, args }` - apply a closure\n- Closures needed for `spawn(|| ...)` syntax in the language\n\n## Design Considerations\n\n- Captured values must be copied (Erlang semantics - no shared mutable state)\n- Closure arity must be tracked\n- Consider: should closures be first-class values passable in messages?","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-02T08:10:20.504413-06:00","updated_at":"2026-01-02T11:53:08.710599-06:00","closed_at":"2026-01-02T11:53:08.710599-06:00","close_reason":"Implemented closures with MakeClosure instruction and extended Apply to handle Value::Closure. 4 new tests added (80 total).","labels":["vm"],"dependencies":[{"issue_id":"toybeam-ba2","depends_on_id":"toybeam-6qv","type":"blocks","created_at":"2026-01-02T08:13:07.941029-06:00","created_by":"daemon"}]}
{"id":"toybeam-che","title":"List BIFs","description":"Add built-in list operations.\n\n## Requirements\n\n- `ListLength { list, dest }` - O(n) length\n- `ListAppend { a, b, dest }` - concatenate lists (++)\n- `ListReverse { list, dest }` - reverse a list\n- `ListNth { list, n, dest }` - get nth element (0-based)\n- `ListMember { elem, list, dest }` - check membership\n\n## Future Additions\n\n- `ListMap`, `ListFilter`, `ListFold` (or implement in language)\n- `ListSort` with comparator\n- `ListFlatten`","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-02T08:11:37.170302-06:00","updated_at":"2026-01-02T08:11:37.170302-06:00","labels":["vm"]}
{"id":"toybeam-dwe","title":"Guards in pattern matching","description":"Add guard expressions to pattern matching.\n\n## Requirements\n\n- Guards are boolean expressions evaluated after pattern match succeeds\n- If guard fails, try next clause\n- Support in both `Match` and `ReceiveMatch` instructions\n\n## Syntax Example (future language)\n\n```rust\nfn abs(n) when n \u003c 0 -\u003e -n;\nfn abs(n) -\u003e n;\n\nreceive {\n    (value, pid) when value \u003e 0 =\u003e send(pid, :positive),\n    (value, pid) =\u003e send(pid, :non_positive)\n}\n```\n\n## Implementation Options\n\n1. Guard as separate instruction sequence with bool result\n2. Guard as expression AST evaluated by VM\n3. Inline guard checks in pattern match instruction","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-02T08:10:51.828003-06:00","updated_at":"2026-01-02T08:10:51.828003-06:00","labels":["vm"],"dependencies":[{"issue_id":"toybeam-dwe","depends_on_id":"toybeam-6p0","type":"blocks","created_at":"2026-01-02T08:13:08.129522-06:00","created_by":"daemon"}]}
{"id":"toybeam-elo","title":"Timers (send_after, start_timer)","description":"Add timer support for delayed message sending.\n\n## Requirements\n\n- `SendAfter { delay, to, msg, dest }` - send message after delay, store timer ref\n- `StartTimer { delay, dest_reg, msg, timer_dest }` - start timer that sends `{:timeout, ref, msg}`\n- `CancelTimer { timer_ref }` - cancel a pending timer\n- Timer delay in milliseconds (or reductions for deterministic testing)\n\n## Use Cases\n\n- Heartbeat/keepalive patterns\n- Request timeouts\n- Periodic tasks\n- Debouncing\n\n## Implementation\n\n- Scheduler maintains timer heap/queue\n- Timers checked each scheduler step\n- Timer refs for cancellation","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-02T08:11:21.533712-06:00","updated_at":"2026-01-02T08:11:21.533712-06:00","labels":["vm"],"dependencies":[{"issue_id":"toybeam-elo","depends_on_id":"toybeam-mje","type":"blocks","created_at":"2026-01-02T08:13:15.40169-06:00","created_by":"daemon"}]}
{"id":"toybeam-h5z","title":"Compiler: Lexer and parser","description":"Build lexer and parser for the Rust-like language.\n\n## Requirements\n\n### Lexer\n- Tokenize: keywords, identifiers, literals, operators, punctuation\n- Handle comments (// and /* */)\n- Track source locations for error messages\n\n### Parser\n- Recursive descent or use parser combinator library (nom, pest, lalrpop)\n- Produce AST\n\n### Initial Grammar (subset)\n```\nmodule      = \"mod\" IDENT \"{\" item* \"}\"\nitem        = function | struct | const\nfunction    = \"fn\" IDENT \"(\" params \")\" (\"-\u003e\" type)? block\nparams      = (IDENT \":\" type (\",\" IDENT \":\" type)*)?\nblock       = \"{\" stmt* expr? \"}\"\nstmt        = let_stmt | expr_stmt\nexpr        = match_expr | if_expr | call | binary_op | ...\n```\n\n## Tooling Options\n\n- Hand-written recursive descent (most control)\n- `logos` for lexer + hand-written parser\n- `lalrpop` for full parser generator\n- `pest` for PEG parsing","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-02T08:12:43.679561-06:00","updated_at":"2026-01-02T13:18:25.496384-06:00","closed_at":"2026-01-02T13:18:25.496384-06:00","close_reason":"Implemented lexer and parser with logos. Supports functions, structs, enums, match, if, receive, spawn, send. 17 compiler tests added (97 total).","labels":["compiler"]}
{"id":"toybeam-hqc","title":"Maps data type","description":"Add maps (hash tables) for key-value storage.\n\n## Requirements\n\n- `Value::Map(HashMap\u003cValue, Value\u003e)` - key-value map\n- Instructions:\n  - `MakeMap { pairs, dest }` - create from key-value pairs on stack\n  - `MapGet { map, key, dest }` - get value (crashes if missing)\n  - `MapGetDefault { map, key, default, dest }` - get with default\n  - `MapPut { map, key, value, dest }` - insert/update (returns new map)\n  - `MapRemove { map, key, dest }` - remove key (returns new map)\n  - `MapHas { map, key, dest }` - check if key exists\n  - `MapSize { map, dest }` - get number of entries\n- Pattern matching on maps\n\n## Notes\n\n- Maps are immutable (functional updates return new map)\n- Keys can be any value type\n- Need Eq + Hash for Value (or use BTreeMap with Ord)","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-02T08:11:21.9657-06:00","updated_at":"2026-01-02T08:11:21.9657-06:00","labels":["vm"]}
{"id":"toybeam-id0","title":"Floats and numeric operations","description":"Add floating-point numbers.\n\n## Requirements\n\n- `Value::Float(f64)` - 64-bit float\n- `LoadFloat { value, dest }` instruction\n- Arithmetic works with mixed int/float (promote to float)\n- Float-specific operations:\n  - `Floor`, `Ceil`, `Round`, `Trunc`\n  - `Sqrt`, `Pow`, `Abs`\n- Comparison across int/float\n\n## Considerations\n\n- NaN handling\n- Float equality in pattern matching (exact vs epsilon)","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-02T08:11:36.958402-06:00","updated_at":"2026-01-02T08:11:36.958402-06:00","labels":["vm"]}
{"id":"toybeam-ill","title":"Process dictionary","description":"Add per-process key-value storage.\n\n## Requirements\n\n- Each process has a local dictionary (HashMap)\n- Instructions:\n  - `PutDict { key, value }` - store value, returns old value or None\n  - `GetDict { key, dest }` - get value or None\n  - `EraseDict { key, dest }` - remove and return value\n  - `GetDictKeys { dest }` - get all keys as list\n\n## Use Cases\n\n- Process-local state without passing through all functions\n- Debugging/tracing context\n- Caching\n\n## Notes\n\n- Controversial in Erlang (hidden state), but useful\n- Dictionary cleared on process exit","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-02T08:11:37.378315-06:00","updated_at":"2026-01-02T08:11:37.378315-06:00","labels":["vm"]}
{"id":"toybeam-lp3","title":"try/catch/after error handling","description":"Add structured error handling.\n\n## Requirements\n\n- `Try { catch_target, after_target }` - begin try block\n- `EndTry` - successful completion of try block\n- `Throw { class, reason }` - throw an exception\n  - Classes: `:error`, `:exit`, `:throw`\n- Catch block receives `{class, reason, stacktrace}`\n- After block always runs (cleanup)\n\n## Semantics\n\n```rust\ntry {\n    risky_operation()\n} catch {\n    (:error, reason) =\u003e handle_error(reason),\n    (:exit, reason) =\u003e handle_exit(reason)\n} after {\n    cleanup()\n}\n```\n\n## Implementation\n\n- Exception stack in process state\n- Unwind to nearest catch on throw\n- After blocks must run even on exception","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-02T08:11:50.54581-06:00","updated_at":"2026-01-02T08:11:50.54581-06:00","labels":["vm"]}
{"id":"toybeam-mje","title":"References (make_ref)","description":"Add unique reference values for request/response correlation.\n\n## Requirements\n\n- `Value::Ref(u64)` - globally unique reference\n- `MakeRef { dest }` instruction - creates new unique ref\n- Refs are comparable for equality only\n- Used for call/response patterns:\n\n```rust\nlet ref = make_ref();\nsend(server, (ref, :get_data));\nreceive {\n    (^ref, data) =\u003e data  // Match only our response\n}\n```\n\n## Implementation\n\n- Scheduler maintains global ref counter\n- Each ref is unique across all processes","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-02T08:10:52.035315-06:00","updated_at":"2026-01-02T08:10:52.035315-06:00","labels":["vm"]}
{"id":"toybeam-muk","title":"Exit reasons and trap_exit","description":"Add proper exit signals with reasons and trap_exit flag.\n\n## Requirements\n\n### Exit Reasons\n- Processes exit with a reason (not just crash/normal)\n- `Exit { reason: Value }` instruction\n- Exit reasons propagate through links\n- Normal exit = `:normal` atom\n\n### trap_exit Flag\n- Process flag to convert exit signals to messages\n- When trap_exit=true, linked process crash sends `{:EXIT, Pid, Reason}` message\n- `SetFlag { flag, value }` instruction\n- `TrapExit` flag enum\n\n### Link Behavior\n- Normal exit: no signal to linked processes (unless trap_exit)\n- Abnormal exit: signal all linked processes\n- trap_exit converts signals to mailbox messages","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-02T08:10:20.925012-06:00","updated_at":"2026-01-02T08:10:20.925012-06:00","labels":["vm"]}
